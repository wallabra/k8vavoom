//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//
//  Extended player object info
//
//**************************************************************************
class BasePlayer : GameObject native abstract;

// constants for FixedColormap
enum {
  NUMCOLORMAPS    = 32,
  INVERSECOLORMAP = 32,
  GOLDCOLORMAP    = 33,
  REDCOLORMAP     = 34,
  GREENCOLORMAP   = 35,
};

const float TOCENTRE = -128.0;

struct VViewState {
  state State; // `none` state means not active
  float StateTime;
  float SX, SY;
  float OfsY;
};

readonly LevelInfo Level;

readonly bool bActive;
readonly bool bSpawned;
readonly bool bIsBot;
bool bFixAngle;
bool bAttackDown; // `true` if button down last tic
bool bUseDown;
bool bDidSecret; // `true` if secret level has been done
readonly private bool bCentreing;
readonly bool bIsClient; // player on client side
bool bAutomapRevealed;
bool bAutomapShowThings;
bool bReloadQueued; // true if "reload" was pressed

native readonly private void *Net;

string UserInfo;

string PlayerName;
ubyte BaseClass;
ubyte PClass; // player class type
ubyte TranslStart;
ubyte TranslEnd;
int Color;

float ClientForwardMove; // *2048 for move
float ClientSideMove; // *2048 for move
float ForwardMove; // *2048 for move
float SideMove; // *2048 for move
float FlyMove; // fly up/down/centreing
/*ubyte*/transient int Buttons; // fire, use
/*ubyte*/transient int Impulse; // weapon changes, inventory, etc
// for ACS, see C++ code
transient int AcsCurrButtonsPressed;
transient int AcsCurrButtons;
transient int AcsButtons;
transient int OldButtons;
transient float AcsNextButtonUpdate;
transient float AcsPrevMouseX, AcsPrevMouseY; // previous ACS mouse movement
transient float AcsMouseX, AcsMouseY; // current ACS mouse movement

Entity MO;
Entity Camera;
int PlayerState;

// determine POV, including viewpoint bobbing during movement
// focal origin above r.z
TVec ViewOrg;

TAVec ViewAngles;

// this is only used between levels,
// mo->health is used during levels.
int Health;

// frags, kills of other players
int Frags;
int Deaths;

// for intermission stats
int KillCount;
int ItemCount;
int SecretCount;

// so gun flashes light up areas
ubyte ExtraLight;

// for lite-amp and invulnarability powers
ubyte FixedColormap;

// color shifts for damage, powerups and content types
int CShift;

// overlay view sprites (gun, etc)
VViewState[NUMPSPRITES] ViewStates;
int[NUMPSPRITES] DispSpriteFrame;
name[NUMPSPRITES] DispSpriteName;
float PSpriteSY;
float PSpriteWeaponLowerPrev;
float PSpriteWeaponLoweringStartTime;
float PSpriteWeaponLoweringDuration;

float WorldTimer; // total time the player's been playing

native readonly ubyte ClientNum;

int SoundEnvironment;

native readonly ClientGameBase ClGame; // valid only on client side

PlayerReplicationInfo playerReplicationInfo;

//private native transient void *fldPendingWeapon;
//private native transient void *fldReadyWeapon;

//private native transient Object lastReadyWeapon;
//private native transient state lastReadyWeaponReadyState;
private native transient Object[NUMPSPRITES] LastViewObject;


replication {
  reliable if (!bIsClient)
    Health, Frags, Deaths, ExtraLight, FixedColormap, CShift,
    PSpriteSY, KillCount, ItemCount, SecretCount,
    ViewStates, DispSpriteFrame, DispSpriteName,
    ClientNum, WorldTimer, MO, Camera, bAutomapRevealed,
    bAutomapShowThings, SoundEnvironment, bAttackDown, bReloadQueued;

  unreliable if (!bIsClient)
    ClientStartSound, ClientStopSound, ClientSetViewOrg;

  reliable if (!bIsClient)
    ClientStartSequence, ClientAddSequenceChoice, ClientStopSequence,
    ClientPrint, ClientCentrePrint, ClientSetAngles, ClientIntermission,
    ClientPause, ClientSkipIntermission, ClientFinale, ClientChangeMusic,
    ClientSetServerInfo, ClientHudMessage;

  // movement variables
  reliable if (bIsClient)
    ViewAngles, ClientForwardMove, ClientSideMove, FlyMove, Buttons;

  // methods client can execute on server
  reliable if (bIsClient)
    ServerImpulse, ServerSetUserInfo;
}


native static final bool IsCheckpointSpawn { get; }

// print to client
native final void cprint (string format, ...) [printf,1];
// client's centre message
native final void centreprint (string format, ...) [printf,1];
alias centerprint = centreprint;
native final int GetPlayerNum ();
native final void ClearPlayer ();

native final void SetViewObject (Object vobj);
native final void SetViewObjectIfNone (Object vobj);
native final void SetViewState (int position, state stnum);
native final void AdvanceViewStates (float deltaTime);
native final void DisconnectBot ();

// for networking
// OriginId==-666: local (use player's SoundOriginID)
native void ClientStartSound (int SoundId, TVec Org, int OriginId,
                              int Channel, float Volume, float Attenuation, bool Loop);
native void ClientStopSound (int OriginId, int Channel);
native void ClientStartSequence (TVec Origin, int OriginId, name Name, int ModeNum);
native void ClientAddSequenceChoice (int OriginId, name Choice);
native void ClientStopSequence (int OriginId);
native void ClientPrint (string Str);
native void ClientCentrePrint (string Str);
native void ClientSetAngles (TAVec Angles);
native void ClientIntermission (name NextMap);
native void ClientPause (bool Paused);
native void ClientSkipIntermission ();
native void ClientFinale (string Type);
native void ClientChangeMusic (name Song);
native void ClientSetServerInfo (string Key, string Value);
native void ClientHudMessage (string Message, name Font, int Type, int Id,
                              int Color, string ColorName, float x, float y,
                              int HudWidth, int HudHeight, float HoldTime,
                              float Time1, float Time2);

native void ServerSetUserInfo (string Info);


//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================
void PutClientIntoServer () {
}


//==========================================================================
//
//  SpawnClient
//
//==========================================================================
void SpawnClient () {
}


//==========================================================================
//
//  NetGameReborn
//
//==========================================================================
void NetGameReborn () {
}


//==========================================================================
//
//  DisconnectClient
//
//==========================================================================
void DisconnectClient () {
}


//==========================================================================
//
//  UserinfoChanged
//
//==========================================================================
void UserinfoChanged () {
}


//==========================================================================
//
//  PlayerBeforeExitMap
//
//==========================================================================
void PlayerBeforeExitMap () {
}


//==========================================================================
//
//  PlayerExitMap
//
//==========================================================================
void PlayerExitMap (bool clusterChange) {
}


//==========================================================================
//
//  PlayerTick
//
//==========================================================================
void PlayerTick (float deltaTime) {
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
void ClientTick (float deltaTime) {
}


//==========================================================================
//
//  SetViewPos
//
//==========================================================================
void SetViewPos () {
}


//==========================================================================
//
//  PreTravel
//
//==========================================================================
void PreTravel () {
}


//==========================================================================
//
//  ResetInventory
//
//==========================================================================
void ResetInventory () {
}


//==========================================================================
//
//  ResetHealth
//
//==========================================================================
void ResetHealth () {
}


//==========================================================================
//
//  PreraiseWeapon
//
//==========================================================================
void PreraiseWeapon () {
}


//==========================================================================
//
//  UseInventory
//
//==========================================================================
void UseInventory (string Inv) {
}


//==========================================================================
//
//  CheckDoubleFiringSpeed
//
//==========================================================================
bool CheckDoubleFiringSpeed () {
  return false;
}


//==========================================================================
//
//  ServerImpulse
//
//==========================================================================
void ServerImpulse (int AImpulse) {
  Impulse = AImpulse;
}


//==========================================================================
//
//  ClientSetViewOrg
//
//==========================================================================
void ClientSetViewOrg (float x, float y, float z) {
  ViewOrg = vector(x, y, z);
}


//==========================================================================
//
//  PostfixViewHeight
//
//  after player thinker was called, player can be moved by lift,
//  for example. we have to "postfix" view origin to get rid of
//  "sinking into lift" effect
//
//==========================================================================
void PostfixViewHeight () {
}


//==========================================================================
//
//  eventGetReadyWeapon
//
//==========================================================================
Entity eventGetReadyWeapon () {
  return none;
}


//==========================================================================
//
//  IsCheckpointPossible
//
//  this should check player's inventory (and maybe some other things), and
//  return `true` if simple checkpoint-style save is possible
//  (i.e. loader can simply recreate player inventory and health)
//
//  for now, there is no way to inject custom data in checkpoints, so if
//  you have any, return `false` here
//
//==========================================================================
bool IsCheckpointPossible () {
  return true;
}


//==========================================================================
//
//  eventSetReadyWeapon
//
//==========================================================================
void eventSetReadyWeapon (Entity ent, bool instant) {}


//==========================================================================
//
//  ResetToDefaults
//
//  this is called on save loading, etc.
//  reset every important field to default
//
//==========================================================================
void ResetToDefaults () {
}


//==========================================================================
//
//  eventOnSaveLoaded
//
//  this is called after savegame was loaded
//
//==========================================================================
void eventOnSaveLoaded () {
}


//==========================================================================
//
//  eventOnBeforeSave
//
//  this is called before game will be saved
//
//  note that `isCheckpoint` is "advisory",
//  the game may decide to do a full save anyway
//
//==========================================================================
void eventOnBeforeSave (bool isAutosave, bool isCheckpoint) {
}


//==========================================================================
//
//  eventOnAfterSave
//
//  this is called after game was saved
//
//  `isCheckpoint` indicates if we really saved a checkpoint
//
//==========================================================================
void eventOnAfterSave (bool isAutosave, bool isCheckpoint) {
}


//==========================================================================
//
//  QS_Save
//
//==========================================================================
void QS_Save () {}


//==========================================================================
//
//  QS_Load
//
//==========================================================================
void QS_Load () {}


// ////////////////////////////////////////////////////////////////////////// //
// this is hack used for quicksaves
native final void QS_PutInt (string fieldname, int value);
native final void QS_PutName (string fieldname, name value);
native final void QS_PutStr (string fieldname, string value);
native final void QS_PutFloat (string fieldname, float value);

native final int QS_GetInt (string fieldname, optional int defvalue);
native final name QS_GetName (string fieldname, optional name defvalue);
native final string QS_GetStr (string fieldname, optional string defvalue);
native final float QS_GetFloat (string fieldname, optional float defvalue);


// ////////////////////////////////////////////////////////////////////////// //
string GetCurrentArmorClassName () { return "None"; }
int GetCurrentArmorSaveAmount () { return 0; }
float GetCurrentArmorSavePercent () { return 0; }
int GetCurrentArmorMaxAbsorb () { return 0; }
int GetCurrentArmorFullAbsorb () { return 0; }
int GetCurrentArmorActualSaveAmount () { return 0; }


// ////////////////////////////////////////////////////////////////////////// //
// various cheat commands
// if commands starts with `Cheat_`, is void, and has no args, it is console command
// if commands starts with `Cheat_`, ends with '_AC', is void, and is
//   (const ref array!string args, bool newArg, out array!string aclist)
// this is autocompleter

/*
void Cheat_Resurrect () {}
void Cheat_God () {}
void Cheat_Buddha () {}
void Cheat_Summon () {}
void Cheat_NoClip () {}
void Cheat_Gimme () {}
void Cheat_KillAll () {}
void Cheat_Morph () {}
void Cheat_NoWeapons () {}
void Cheat_Class () {}
void Cheat_Fly () {}
void Cheat_NoTarget () {}
void Cheat_Anubis () {}
void Cheat_Freeze () {}
void Cheat_Jumper () {}
void Cheat_ShooterKing () {}
void Cheat_Regeneration () {}
void Cheat_DumpInventory () {}
*/
void Cheat_VScriptCommand (ref array!string args) {}


defaultproperties {
}
