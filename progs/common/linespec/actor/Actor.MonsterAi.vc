//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//  Monster AI
//**************************************************************************

//==========================================================================
//
//  SetSeeOrWanderState
//
//  factored out common code
//  let the actor wander around aimlessly looking for a fight
//
//==========================================================================
final void SetSeeOrWanderState () {
  if (SeeState) {
    // if we are in `A_Chase()`, don't do anything, becase `A_Chase()` will take care of it
    if (!bInChase) {
      if (Level.PerfectHatredMode&LevelInfo::PHM_WANDER) A_Wander(); else SetState(SeeState);
    }
  } else {
    A_Wander();
  }
}


//==========================================================================
//
//  A_Look
//
//  Stay in state until a player is sighted or has a goal.
//
//==========================================================================
[decorate] final void A_Look () {
  EntityEx targ;
  Entity Ent;
  float fov = (bLookAllAround ? 360 : 0);

  // set goal now if appropriate
  if (Special == LNSPEC_ThingSetGoal && Args[0] == 0) {
    Goal = none;
    for (Ent = Level.FindMobjFromTID(Args[1], none); Ent; Ent = Level.FindMobjFromTID(Args[1], Ent)) {
      if (!Ent.IsA('PatrolPoint')) continue;
      Goal = EntityEx(Ent);
      break;
    }
    Special = 0;
    ReactionTime = float(Args[2])+XLevel.Time;
    bChaseGoal = !!Args[3];
  }

  Threshold = 0; // any shot will wake up

  if (TIDToHate) {
    targ = Target;
  } else {
    targ = (Level.CompatSoundTarget || bNoSector ? EntityEx(Sector->SoundTarget) : LastHeard);
    if (targ) {
      // if it's dead, don't chase it
      if (targ && targ.Health <= 0) targ = none;
      if (targ && targ.bIsPlayer) {
        if (PlayerEx(targ.Player).bNoTarget) {
          if (Level.PerfectHatredMode&LevelInfo::PHM_HUNT_MONSTERS) LookForPlayers(fov);
          return;
        }
      }
    }
  }

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = -1;

  if (targ && targ.bShootable) {
    if (bFriendly && targ.bFriendly) {
      // if we find a valid target here, the wandering logic should *not* be activated!
      // if would cause the seestate to be set twice
      if (!LookForPlayers(fov)) SetSeeOrWanderState();
    } else {
      Target = targ;
      if (bAmbush) {
        if (!CanSee(Target)) {
          if (!LookForPlayers(fov)) return;
        }
      }
    }
  } else {
    if (!LookForPlayers(fov)) return;
  }

  // go into chase state
  // don't start chasing after a goal if it isn't time yet
  if (Target == Goal) {
    if (ReactionTime > XLevel.Time) Target = none;
  } else if (SightSound) {
    if (bBoss) {
      // full volume
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT, 1.0, ATTN_NONE);
    } else {
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT);
    }
  }

  if (Target) SetState(SeeState);
}


//==========================================================================
//
//  A_Look2
//
//==========================================================================
[decorate] final void A_Look2 () {
  Threshold = 0; // any shot will wake up
  EntityEx targ = LastHeard;
  float fov = (bLookAllAround ? 360 : 0);

  if (!bNeutral && targ && targ.bShootable) {
    if (bFriendly != targ.bFriendly || Level.bNoAllies) {
      Target = targ;
      if (!bStandMustSeeTarget || CanSee(targ)) {
        Threshold = 10;
        SetSeeOrWanderState();
        return;
      }
    } else {
      if (LookForPlayers(fov)) {
        SetSeeOrWanderState();
        bInCombat = true;
        return;
      }
    }
  }

  if (P_Random() < 30) {
    if (!(P_Random()&1)) {
      SetState(GetStatePlus(IdleState, 1, IgnoreJump:true));
    } else {
      SetState(GetStatePlus(IdleState, 2, IgnoreJump:true));
    }
  }

  if (!bStanding && P_Random() < 40) SetState(GetStatePlus(IdleState, 3, IgnoreJump:true));
}


//==========================================================================
//
//  A_LookEx
//
//  [KS] Borrowed the A_Look code to make a parameterized version.
//
//==========================================================================
[decorate] final void A_LookEx (optional int flags, optional float minseedist, optional float maxseedist,
                     optional float maxheardist, optional float fov,
                     optional /*name*/state wakestate)
{
  EntityEx targ = none;

  //if (self isa 'PSXZombieMan') printdebug("%C:%s:A_LookEx:000: specified_flags=%B; flags=0x%04x; minseedist=%s; maxseedist=%s; maxheardist=%s; fov=%s; wakestate=%s (%B)", self, UniqueId, specified_flags, flags, minseedist, maxseedist, maxheardist, fov, wakestate, specified_wakestate);

  // fix optional args
  if (!fov && bLookAllAround) fov = 360; // use default value if zero
  if (!specified_wakestate) wakestate = SeeState;

  bool dojump = !(flags&LOF_NOJUMP);
  bool doSightCheck = !(flags&LOF_NOSIGHTCHECK);

  // set goal now if appropriate
  if (Special == LNSPEC_ThingSetGoal && Args[0] == 0) {
    Goal = none;
    for (Entity Ent = Level.FindMobjFromTID(Args[1], none); Ent; Ent = Level.FindMobjFromTID(Args[1], Ent)) {
      if (!Ent.IsA('PatrolPoint')) continue;
      Goal = EntityEx(Ent);
      break;
    }
    Special = 0;
    ReactionTime = float(Args[2])+XLevel.Time;
    bChaseGoal = !!Args[3];
  }

  Threshold = 0; // any shot will wake up
  EntityEx hearTarget = none;

  if (TIDToHate) {
    // have something predefined to hate
    targ = Target;
    // do not target self
    if (targ == self) targ = none;
  } else if (!(flags&LOF_NOSOUNDCHECK)) {
    // perform sound check
    targ = (Level.CompatSoundTarget || bNoSector ? EntityEx(Sector->SoundTarget) : LastHeard);
    // do not target self
    if (targ == self) targ = none;
    // if it's dead, don't chase it
    if (targ && targ.Health <= 0) targ = none;

    // [KS] if the target is too far away, don't respond to the sound
    if (targ && maxheardist && DistTo2(targ) > maxheardist) targ = none;
    hearTarget = targ;

    if (targ && targ.bIsPlayer && PlayerEx(targ.Player).bNoTarget) {
      if (Level.PerfectHatredMode&LevelInfo::PHM_HUNT_MONSTERS) LookForPlayers(fov);
      return;
    }
  }

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = -1;

  bool doFindTarget = true; // this is used to block target searching if friendly monster is wandering

  if (targ && targ.bShootable) {
    // got (possibly new) target
    if (IsFriend(targ)) {
      // target is a friend
      // if we'll find a valid target here, the wandering logic should *not* be activated!
      // if would cause the seestate to be set twice
      bool doWander = true;
      if (!doSightCheck && LookForPlayers(fov, minseedist, (maxseedist ? fmin(maxseedist, 1280) : 1280))) {
        if (Target && IsFriend(Target)) Target = none;
        doWander = (Target == none);
      }
      if (doWander) {
        // let the actor wander around aimlessly looking for a fight
        if (dojump && !bInChase) {
          if (wakestate) SetState(wakestate); else A_Wander();
        }
        // we're done here
        return;
      }
      // do not look for a target if we already got one
      doFindTarget = (Target == none);
    } else {
      // target is a foe
      Target = targ;
      // other checks will be done below
    }
  }

  if (doFindTarget) {
    // try to find/validate a target
    // ambushed monster should check if its "ambush target" is still visible
    // normal monster should check if its "non-hearing target" is still visible
    // this is essentially the same logic, so i joined the checks
    // this logic allows the monster to drop its "visible" target if it moved out of sight, and look for someone else
    targ = Target; // if `targ` is `none`, look for a player
    if (targ &&
        (bAmbush || // ambushed?
         !hearTarget || targ != hearTarget)) // target is not came from a sound check?
    {
      // check if we have an unobstructed LOS to our desired target
      float tdist = (minseedist || maxseedist ? DistTo2(targ) : 0); // in case we're not interested in distance checks, don't bother calculating it
      bool targetInRange = (tdist >= minseedist && (!maxseedist || tdist <= maxseedist));
      //k8: gozzo uses `SF_SEEPASTBLOCKEVERYTHING` here
      if (!targetInRange || !CanSee(targ)) targ = none; // look for a player if the target is lost
    }
    // if we have no target, look for a player
    if (!targ) {
      if (!doSightCheck || !LookForPlayers(fov, minseedist, maxseedist)) return; // the monster is blind, or there are no enemies around
    }
  }

  if (!Target) return;

  // don't start chasing after a goal if it isn't the time yet
  if (Target == Goal) {
    if (ReactionTime > XLevel.Time) {
      Target = none;
      return;
    }
  } else if (SightSound && !(flags&LOF_NOSEESOUND)) {
    // play see sound
    if (flags&LOF_FULLVOLSEESOUND) {
      // full volume
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT, 1.0, ATTN_NONE);
    } else {
      PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT);
    }
  }

  // go into chase state
  if (dojump && wakestate) SetState(wakestate);
}


//==========================================================================
//
//  A_TurretLook
//
//  Stay in state untill alarm is triggered.
//
//==========================================================================
[decorate] final void A_TurretLook () {
  Threshold = 0;
  EntityEx targ = LastHeard;
  if (targ && targ.Health > 0 && targ.bShootable && bFriendly != targ.bFriendly) {
    Target = targ;
    if (bAmbush && !CanSee(Target)) return;
    // go into chase state
    if (SightSound) PlaySound(SightSound, /*CHAN_VOICE*/CHAN_SIGHT);
    LastHeard = none;
    Threshold = 10;
    SetState(SeeState);
  }
}


//==========================================================================
//
//  A_Wander
//
//==========================================================================
[decorate] final void A_Wander () {
  decorate_A_Wander();
}


//==========================================================================
//
//  decorate_A_Wander
//
//==========================================================================
[decorate] final void decorate_A_Wander (optional int flags) {
  bInCombat = false;
  if (bStanding) {
    if (!(Level.PerfectHatredMode&LevelInfo::PHM_WANDER)) return;
  }

  if (ReactionCount) {
    if ((--ReactionCount) < 0) ReactionCount = 0; // just in case
    return;
  }

  if (Level.PerfectHatredMode&LevelInfo::PHM_WANDER) {
    // in perfect hatred mode, try to find an enemy sometimes
    if (P_Random() >= 180) {
      printdebug("%C(%s): trying to find an enemy", self, UniqueId);
      if (LookForMonstersPH()) {
        if (Target) {
          printdebug("%C(%s):   found enemy: %C(%s)", self, UniqueId, Target, Target.UniqueId);
          return;
        }
      }
    }
  }

  if (!(flags&CHF_NODIRECTIONTURN)) {
    // turn towards movement direction if not there yet
    if (MoveDir < DI_NODIR) {
      Angles.yaw = float(int(Angles.yaw/45.0))*45.0;
      float delta = AngleMod180(Angles.yaw-float(MoveDir)*45.0);
           if (delta > 0.0) Angles.yaw = AngleMod360(Angles.yaw-45.0);
      else if (delta < 0.0) Angles.yaw = AngleMod360(Angles.yaw+45.0);
    }
  }

  if (flags&CHF_NORANDOMTURN) {
    if (--MoveCount < 0) MoveCount += 5;
    if (!StepMove()) {
      if (!(flags&CHF_STOPIFBLOCKED)) RandomChaseDir();
    }
  } else {
    if (--MoveCount < 0 || !StepMove()) {
      if (!(flags&CHF_STOPIFBLOCKED)) RandomChaseDir();
      MoveCount += 5;
    }
  }
}


//==========================================================================
//
//  DoChase
//
//  Actor has a melee attack, so it tries to close as fast as possible
//
//  FIXME: optional flags are not working
//
//==========================================================================
void DoChase (bool FastChase, state AMeleeState, state AMissileState,
              bool NightmareFast, bool PlayActive, bool DontMove,
              optional bool noRandomTurn, optional bool noDirectionTurn,
              optional bool noPostAttackTurn, optional bool stopIfBlocked)
{
  float delta;
  float dist;
  float ang;
  float oldX;
  float oldY;
  int oldFloor;

  if (bInChase) return;
  bInChase = true;
  scope(exit) bInChase = false;

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = -1;

  if (ReactionCount) --ReactionCount;

  bInCombat = true;
  // modify target threshold
  if (Threshold) {
    if (!Target || Target.Health <= 0) {
      Threshold = 0;
    } else {
      --Threshold;
    }
  }

  if (NightmareFast && Level.Game.fastparm == 1) {
    // monsters move faster in nightmare mode
    StateTime *= 0.5;
    if (StateTime < 0.1) StateTime = 0.1;
  }

  // turn towards movement direction if not there yet
  // killough 9/7/98: keep facing towards target if strafing or backing out
  if (strafecount) {
    A_FaceTarget();
  } else {
    if (MoveDir < 8) {
      Angles.yaw = float(int(Angles.yaw/45.0))*45.0;
      delta = AngleMod180(Angles.yaw-float(MoveDir)*45.0);
           if (delta > 0.0) Angles.yaw = AngleMod360(Angles.yaw-45.0);
      else if (delta < 0.0) Angles.yaw = AngleMod360(Angles.yaw+45.0);
    }
  }

  // if the target is dead and not a goal, stop chasing it
  if (Target && Target != Goal && Target.Health <= 0) Target = none;

  if (!Target || !Target.bShootable) {
    // look for a new target
    if (LookForPlayers(360) && Target != Goal) return; // got a new target
    if (!Target) {
      if (bFriendly) {
        A_Look();
        if (!Target) {
          if (!DontMove) A_Wander();
          return;
        }
      } else {
        if (Level.PerfectHatredMode&LevelInfo::PHM_WANDER) {
          A_Wander();
        } else {
          SetState(IdleState);
          bInCombat = false;
        }
        return;
      }
    }
  }

  // do not attack twice in a row
  if (bJustAttacked) {
    bJustAttacked = false;
    if (!IsFast() && !DontMove) NewChaseDir();
    return;
  }

  // don't attack if just moving toward goal
  if (Target == Goal || (bChaseGoal && Goal)) {
    EntityEx SavedTarget = Target;
    Target = Goal;
    bool Result = CheckMeleeRange();
    Target = SavedTarget;

    if (Result) {
      // reached the goal

      // execute the specials of any PatrolSpecials with the same TID as the goal
      Entity Ent;
      for (Ent = Level.FindMobjFromTID(Goal.TID, none); Ent; Ent = Level.FindMobjFromTID(Goal.TID, Ent)) {
        if (Ent.Class != PatrolSpecial) continue;
        Level.ExecuteActionSpecial(Ent.Special, Ent.Args[0],
          Ent.Args[1], Ent.Args[2], Ent.Args[3], Ent.Args[4],
          nullptr, 0, self);
      }

      float LastGoalAng = Goal.Angles.yaw;
      int Delay;
      EntityEx NewGoal = none;
      for (Ent = Level.FindMobjFromTID(Goal.Args[0], none); Ent; Ent = Level.FindMobjFromTID(Goal.Args[0], Ent)) {
        if (!Ent.IsA('PatrolPoint')) continue;
        NewGoal = EntityEx(Ent);
        break;
      }
      if (NewGoal && Goal == Target) {
        Delay = NewGoal.Args[1];
        ReactionTime = float(Delay)+XLevel.Time;
      } else {
        Delay = 0;
        ReactionTime = default.ReactionTime;
        Angles.yaw = LastGoalAng; // look in direction of last goal
      }
      if (Target == Goal) Target = none;
      bJustAttacked = true;
      if (NewGoal && Delay != 0) {
        bInCombat = true;
        SetState(IdleState);
      }
      Goal = NewGoal;
      return;
    }
  }

  if (Goal != Target) {
    if (FastChase && !DontMove) {
      // strafe
      if (FastChaseStrafeCount > 0) {
        --FastChaseStrafeCount;
      } else {
        FastChaseStrafeCount = 0;
        Velocity.x = 0.0;
        Velocity.y = 0.0;
        dist = DistTo2(Target); // was `DistTo()`
        if (dist < 640.0) {
          if (P_Random() < 100) {
            ang = atan2(Target.Origin.y-Origin.y, Target.Origin.x-Origin.x);
            if (P_Random() < 128) ang = AngleMod360(ang+90.0); else ang = AngleMod360(ang-90.0);
            Velocity.x = 13.0*cos(ang)*35.0;
            Velocity.y = 13.0*sin(ang)*35.0;
            FastChaseStrafeCount = 3; // strafe time
          }
        }
      }
    }

    // scared monsters attack less frequently
    // k8: i cannot get this logic; let's hope i put parens at the right place
    if (((!Target.bIsPlayer || !(PlayerEx(Target.Player).Cheats&PlayerEx::CF_FRIGHTENING)) && !bFrightened) || P_Random() < 43) {
      // check for melee attack
      if (AMeleeState && CheckMeleeRange()) {
        if (AttackSound) PlaySound(AttackSound, CHAN_WEAPON);
        SetState(AMeleeState);
        return;
      }

      // check for missile attack
      if (AMissileState) {
        if (IsFast() || !MoveCount) {
          if (CheckMissileRange()) {
            SetState(AMissileState);
            bJustAttacked = true;
            return;
          }
        }
      }
    }
  }

  // possibly choose another target
  if ((Level.Game.netgame || TIDToHate) && !Threshold) {
    if (!CanSee(Target)) {
      bool PrevNoSightCheck = bNoSightCheck;
      bNoSightCheck = false;
      bool GotNew = LookForPlayers(360);
      bNoSightCheck = PrevNoSightCheck;
      if (GotNew) return; // got a new target
    }
  }

  if (strafecount) --strafecount;

  // chase towards player
  if ((!FastChase || !FastChaseStrafeCount) && !DontMove) {
    oldX = Origin.x;
    oldY = Origin.y;
    oldFloor = Sector->floor.pic;
    //k8: dunno if this is right
    bool tryMoveAgain = true;
         if (--MoveCount < 0) NewChaseDir();
    else if (!StepMove()) { tryMoveAgain = false; NewChaseDir(); }
    if (!stopIfBlocked) tryMoveAgain = true;
    if (tryMoveAgain && bCantLeaveFloorpic && Sector->floor.pic != oldFloor) {
      TryMove(vector(oldX, oldY, Origin.z), AllowDropOff:false);
      NewChaseDir();
    }
  } else if (DontMove && MoveCount > 0) {
    MoveCount = 0;
  }

  // make active sound
  if (PlayActive && P_Random() < 3) PlayActiveSound();
}


//==========================================================================
//
//  CheckForResurrect
//
//  Check for ressurecting a body.
//
//==========================================================================
final bool CheckForResurrect (bool UseVileStates) {
  float viletryx;
  float viletryy;
  Entity Other;

  if (MoveDir != DI_NODIR) {
    // check for corpses to raise
    viletryx = Origin.x+Speed/35.0*LineSpecialGameInfo(Level.Game).xspeed[MoveDir];
    viletryy = Origin.y+Speed/35.0*LineSpecialGameInfo(Level.Game).yspeed[MoveDir];

    // for all things in radius check whether object is a corpse that can be raised
    foreach RadiusThings(Other, vector(viletryx, viletryy, 0.0), MAXRADIUS) {
      // detect a corpse that could be raised
      float maxdist = Other.Radius+Radius;

      if (fabs(Other.Origin.x-viletryx) > maxdist ||
          fabs(Other.Origin.y-viletryy) > maxdist)
      {
        continue; // not actually touching
      }

      if (!CanSee(Other, disableBetterSight:true)) continue; // can't see, possibly in other region

      if (!EntityEx(Other).DoThingRaise()) continue;

      // this is now a archvile minion, so hate what he hates
      EntityEx(Other).CopyFriendliness(self, false);

      // got one!
      EntityEx temp = Target;
      Target = EntityEx(Other);
      A_FaceTarget();
      Target = temp;

      // enter heal state
      state HealState = FindState('Heal');
      if (!HealState && UseVileStates) {
        // for DeHackEd compatibility use Arch-vile heal states if this one doesn't have it's own
        HealState = FindClassState(Archvile, 'Heal');
      }
      if (HealState) SetState(HealState);

      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  A_Chase
//
//==========================================================================
[decorate] final void A_Chase () {
  DoChase(false, MeleeState, MissileState, LineSpecialGameInfo(Level.Game).bNightmareFastChase, true, false);
}


//==========================================================================
//
//  decorate_A_Chase
//
//==========================================================================
[decorate] final void decorate_A_Chase (optional state AMeleeState, optional state AMissileState, optional int Flags) {
  if (!specified_AMeleeState) AMeleeState = MeleeState;
  if (!specified_AMissileState) AMissileState = MissileState;
  if (!specified_Flags) {
    DoChase(FastChase:false, MeleeState, MissileState, NightmareFast:LineSpecialGameInfo(Level.Game).bNightmareFastChase, PlayActive:true, DontMove:false);
  } else {
    if ((Flags&8) && CheckForResurrect(false)) return;
    DoChase(FastChase:!!(Flags&1), AMeleeState, AMissileState,
            NightmareFast:!!(Flags&4), PlayActive:!(Flags&2), DontMove:!!(Flags&16),
            noRandomTurn:!!(Flags&32), noDirectionTurn:!!(Flags&64), noPostAttackTurn:!!(Flags&128), stopIfBlocked:!!(Flags&256));
  }
  /*
  if (specified_AMeleeState) {
    if ((Flags&8) && CheckForResurrect(false)) return;
    DoChase(FastChase:!!(Flags&1), AMeleeState, AMissileState,
            NightmareFast:!!(Flags&4), PlayActive:!(Flags&2), DontMove:!!(Flags&16),
            noRandomTurn:!!(Flags&32), noDirectionTurn:!!(Flags&64), noPostAttackTurn:!!(Flags&128), stopIfBlocked:!!(Flags&256));
  } else {
    DoChase(FastChase:false, MeleeState, MissileState, LineSpecialGameInfo(Level.Game).bNightmareFastChase, PlayActive:true, DontMove:false);
  }
  */
}


//============================================================================
//
//  A_FastChase
//
//============================================================================
[decorate] final void A_FastChase () {
  DoChase(true, MeleeState, MissileState, true, true, false);
}


//==========================================================================
//
//  A_VileChase
//
//==========================================================================
[decorate] final void A_VileChase () {
  if (!CheckForResurrect(true)) A_Chase(); // return to normal attack
}


//==========================================================================
//
//  A_ExtChase
//
//==========================================================================
[decorate] final void A_ExtChase (bool UseMelee, bool UseMissile, optional bool PlayActive, optional bool NightmareFast) {
  if (!specified_PlayActive) PlayActive = true;
  state Melee = MeleeState;
  if (!UseMelee) Melee = none;
  state Missile = MissileState;
  if (!UseMissile) Missile = none;
  DoChase(false, Melee, Missile, NightmareFast, PlayActive, false);
}


//==========================================================================
//
//  A_FaceTarget
//
//==========================================================================
[decorate] final void A_FaceTarget () {
  decorate_A_FaceTarget();
}


//==========================================================================
//
//  decorate_A_FaceTarget
//
//==========================================================================
[decorate] final void decorate_A_FaceTarget (optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  common_A_FaceSomething(Target, max_turn!optional, max_pitch!optional,
                         ang_offset!optional, pitch_offset!optional,
                         flags!optional, z_ofs!optional);
}


//==========================================================================
//
//  decorate_A_FaceTracer
//
//==========================================================================
[decorate] final void decorate_A_FaceTracer (optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  common_A_FaceSomething(Tracer, max_turn!optional, max_pitch!optional,
                         ang_offset!optional, pitch_offset!optional,
                         flags!optional, z_ofs!optional);
}


//==========================================================================
//
//  decorate_A_FaceMaster
//
//==========================================================================
[decorate] final void decorate_A_FaceMaster (optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  common_A_FaceSomething(Master, max_turn!optional, max_pitch!optional,
                         ang_offset!optional, pitch_offset!optional,
                         flags!optional, z_ofs!optional);
}


//==========================================================================
//
//  common_A_FaceSomething
//
//==========================================================================
final void common_A_FaceSomething (EntityEx Tgt, optional float max_turn, optional float max_pitch,
                                  optional float ang_offset, optional float pitch_offset,
                                  optional int flags, optional float z_ofs)
{
  if (!Tgt || Tgt == self) return;

  // Andy Baker's stealth monsters
  if (bStealth) VisDir = 1;

  bAmbush = false;

  float newyaw = AngleTo(Tgt);
  float adiff = AngleDelta(Angles.yaw, newyaw);

  if (specified_max_turn && max_turn < adiff) {
    if (adiff < 0) Angles.yaw -= max_turn+ang_offset; else Angles.yaw += max_turn+ang_offset;
  } else {
    Angles.yaw = newyaw+ang_offset;
  }
  Angles.yaw = AngleMod360(Angles.yaw);

  if (specified_max_pitch && max_pitch <= 180) {
    TVec dist = Tgt.Origin-Origin;
    dist.z = 0;

    // positioning ala missile spawning, 32 units above foot level
    float source_z = Origin.z+32;
    float target_z;

    // if the target z is above the target's head, reposition to the middle of its body
    if (source_z >= Origin.z+Height) source_z = GetCenterZ();

    if (flags&(FAF_BOTTOM|FAF_MIDDLE|FAF_TOP)) {
      // note there is no +32 on purpose. this is for customization sake.
      // if one doesn't want this behavior, just don't use FAF_BOTTOM.
      if (flags&FAF_BOTTOM) target_z = Tgt.Origin.z;
      if (flags&FAF_MIDDLE) target_z = Tgt.GetCenterZ();
      if (flags&FAF_TOP) target_z = Tgt.Origin.z+Tgt.Height;
    } else {
      target_z = Tgt.Origin.z+32;
      if (target_z >= Tgt.Origin.z+Tgt.Height) target_z = Tgt.GetCenterZ();
    }

    target_z += z_ofs;

    float dist_z = target_z-source_z;
    if (dist_z > 0) {
      float ddist = sqrt(dist.x*dist.x+dist.y*dist.y+dist_z*dist_z);
      if (ddist > 0) {
        float other_pitch = AngleMod180(-asin(dist_z/ddist));
        if (max_pitch != 0) {
          if (Angles.pitch > other_pitch) {
            max_pitch = AngleMod360(fmin(max_pitch, Angles.pitch-other_pitch));
            Angles.pitch -= max_pitch;
          } else {
            max_pitch = AngleMod360(fmin(max_pitch, other_pitch-Angles.pitch));
            Angles.pitch += max_pitch;
          }
        } else {
          Angles.pitch = other_pitch;
        }
        Angles.pitch += pitch_offset;
      }
    }
  }

  if (!max_turn && !ang_offset && Tgt.bShadow && !bSeeInvisible) {
    Angles.yaw = AngleMod360(Angles.yaw+(Random()-Random())*45.0);
  }
}


//==========================================================================
//
//  A_Die
//
//==========================================================================
[decorate] final void A_Die (optional name adamagetype) {
  if (!specified_adamagetype) {
    Damage(none, none, Health, forced:true);
  } else {
    Damage(none, none, Health, adamagetype, forced:true);
  }
}


//==========================================================================
//
//  A_CentaurDefend
//
//==========================================================================
[decorate] final void A_CentaurDefend () {
  A_FaceTarget();
  if (CheckMeleeRange() && Random() < 0.125) {
    A_UnSetInvulnerable();
    SetState(MeleeState);
  }
}


//==========================================================================
//
//  A_AlertMonsters
//
//==========================================================================
[decorate] final void A_AlertMonsters (optional float maxrange, optional int flags) {
  //print("A_AlertMonsters(%C): tgt=%C; plr=%s", self, Target, (Target && Target.bIsPlayer ? "tan" : "ona"));
  if (Target && (Target.bIsPlayer || (flags&(AMF_TARGETEMITTER|AMF_TARGETNONPLAYER)))) {
    LineSpecialLevelInfo(Level).NoiseAlert(target:Target, emitter:self, maxdist:maxrange!optional,
                                           targetEmitter:!!(flags&AMF_TARGETEMITTER),
                                           targetNonPlayer:!!(flags&AMF_TARGETNONPLAYER),
                                           emitFromTarget:!!(flags&AMF_EMITFROMTARGET));
  } else {
    // for weapons
    if (self.bIsPlayer || (flags&(AMF_TARGETEMITTER|AMF_TARGETNONPLAYER))) {
      LineSpecialLevelInfo(Level).NoiseAlert(target:self, emitter:self, maxdist:maxrange!optional,
                                             targetEmitter:!!(flags&AMF_TARGETEMITTER),
                                             targetNonPlayer:!!(flags&AMF_TARGETNONPLAYER),
                                             emitFromTarget:!!(flags&AMF_EMITFROMTARGET));
    }
  }
}


//==========================================================================
//
//  A_ClearTarget
//
//==========================================================================
[decorate] final void A_ClearTarget () {
  Target = none;
  LastEnemy = none;
  LastHeard = none;
}


//==========================================================================
//
//  A_ClearSoundTarget
//
//==========================================================================
[decorate] final void A_ClearSoundTarget () {
  Sector->SoundTarget = none;
  for (Entity Ent = Sector->ThingList; Ent; Ent = Ent.SNext) {
    EntityEx(Ent).LastHeard = none;
  }
}


//==========================================================================
//
//  doKillXXX
//
//  worker for A_KillXXX
//
//==========================================================================
final void doKillXXX (EntityEx dest, name adamagetype, int flags, optional name filter,
                      optional name aspecies, optional int src, optional int inflict)
{
  if (!dest) return;

  if (!dest.DecorFilterCheck(invertFilter:!!(flags&KILS_EXFILTER), invertSpecies:!!(flags&KILS_EXSPECIES), either:!!(flags&KILS_EITHER), filter:filter!optional, aspecies:aspecies!optional)) return;

  if (!(flags&KILS_KILLMISSILES)) {
    if (dest.IsMissile(false)) return;
  }
  if (flags&KILS_NOMONSTERS) {
    if (dest.bMonster) return;
  }

  // get source and inflictor
  EntityEx source = EntityEx(DecorDoAAPtr('doKillXXX', src!optional));
  EntityEx inflictor = EntityEx(DecorDoAAPtr('doKillXXX', inflict!optional));

  // fix damage type
  if (inflictor && (flags&DMSS_INFLICTORDMGTYPE)) adamagetype = inflictor.DamageType;

  dest.Damage(inflictor, source, dest.Health, adamagetype, NoArmor:true, forced:!!(flags&KILS_FOILINVUL), ignoreDamageFactors:true, ignorePowerups:true);
}


//==========================================================================
//
//  A_KillMaster
//
//==========================================================================
[decorate] final void A_KillMaster (optional name adamagetype, optional int flags,
                         optional name filter, optional name aspecies,
                         optional int src, optional int inflict)
{
  //if (Master) Master.Damage(self, self, Master.Health, default, true);
  doKillXXX(Master, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  A_KillTarget
//
//==========================================================================
[decorate] final void A_KillTarget (optional name adamagetype, optional int flags,
                         optional name filter, optional name aspecies,
                         optional int src, optional int inflict)
{
  doKillXXX(Target, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  A_KillTracer
//
//==========================================================================
[decorate] final void A_KillTracer (optional name adamagetype, optional int flags,
                         optional name filter, optional name aspecies,
                         optional int src, optional int inflict)
{
  doKillXXX(Tracer, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  A_KillChildren
//
//==========================================================================
[decorate] final void A_KillChildren (optional name adamagetype, optional int flags,
                           optional name filter, optional name aspecies,
                           optional int src, optional int inflict)
{
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master != self) continue;
    doKillXXX(A, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
  }
}


//==========================================================================
//
//  A_KillSiblings
//
//==========================================================================
[decorate] final void A_KillSiblings (optional name adamagetype, optional int flags,
                           optional name filter, optional name aspecies,
                           optional int src, optional int inflict)
{
  EntityEx mainMaster = Master;
  if (!mainMaster) return;
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master == mainMaster && A != self) {
      doKillXXX(A, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
    }
  }
}


//==========================================================================
//
//  A_RaiseMaster
//
//==========================================================================
[decorate] final void A_RaiseMaster (optional int flags) {
  if (!Master) return;
  if (Master.DoThingRaise(!!(flags&RF_NOCHECKPOSITION))) {
    if (flags&RF_TRANSFERFRIENDLINESS) Master.CopyFriendliness(self, false);
  }
}


//==========================================================================
//
//  A_RaiseChildren
//
//==========================================================================
[decorate] final void A_RaiseChildren (optional int flags) {
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master != self) continue;
    if (A.DoThingRaise(!!(flags&RF_NOCHECKPOSITION))) {
      if (flags&RF_TRANSFERFRIENDLINESS) A.CopyFriendliness(self, false);
    }
  }
}


//==========================================================================
//
//  A_RaiseSiblings
//
//==========================================================================
[decorate] final void A_RaiseSiblings (optional int flags) {
  EntityEx mainMaster = Master;
  if (!mainMaster) return;
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master == mainMaster && A != self) {
      if (A.DoThingRaise(!!(flags&RF_NOCHECKPOSITION))) {
        if (flags&RF_TRANSFERFRIENDLINESS) A.CopyFriendliness(self, false);
      }
    }
  }
}


//==========================================================================
//
//  A_SentinelBob
//
//==========================================================================
[decorate] final void A_SentinelBob () {
  if (bInFloat) { Velocity.z = 0.0; return; }

  if (Threshold) return;

  float maxz = CeilingZ-Height-16.0;
  float minz = FloorZ+96.0;
  if (minz > maxz) minz = maxz;

  if (minz < Origin.z) {
    Velocity.z -= 1.0*35.0;
  } else {
    Velocity.z += 1.0*35.0;
  }
  ReactionCount = (minz >= Origin.z ? 4 : 0);
}


//==========================================================================
//
//  A_Burst
//
//==========================================================================
[decorate] final void A_Burst (class!Actor ChunkType) {
  if (!ChunkType) return;
  ChunkType = GetCompatibleClassReplacement(Actor, ChunkType);
  if (!ChunkType) return;

  // stop the thing and reset it's height
  Velocity = vector(0.0, 0.0, 0.0);
  Height = default.Height;

  //  Calculate number of chunks based on the size of the thing.
  int NumChunks = int(Radius*Height)/32;
  if (NumChunks < 4) NumChunks = 4;

  int i = NumChunks+((P_Random()-P_Random())%(NumChunks/4));
  if (i < 24) i = 24;
  for (; i >= 0; --i) {
    Actor A = SpawnEntityChecked(class!Actor, ChunkType, Origin+vector((Random()-0.5)*2.0*Radius, (Random()-0.5)*2.0*Radius, Random()*Height));
    if (A) {
      A.Velocity.z = (A.Origin.z-Origin.z)/Height*4.0*35.0;
      A.Velocity.x = (Random()-Random())*2.0*35.0;
      A.Velocity.y = (Random()-Random())*2.0*35.0;
      A.RenderStyle = RenderStyle;
      A.Alpha = Alpha;
      A.CopyFriendliness(self, true);
    }
  }

  // if it's a boss, execute special boss death actions
  if (bBossDeath) A_BossDeath();

  // drop items and go away
  A_NoBlocking();
  Destroy();
}


//==========================================================================
//
//  do_CheckProximity
//
//  this is used both for decorate and for ACSF
//
//==========================================================================
override bool do_CheckProximity (name classname, float distance, optional int count, optional int flags, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckProximity', aptr!optional));
  //if (!specified_aptr && tgt != Target) Error("WUTA?! in `A_CheckProximity`");
  if (!tgt) return false;

  if (flags&CPXF_SETONPTR) {
    //k8: is this right?
    if (flags&CPXF_SETTARGET) tgt.Target = none;
    if (flags&CPXF_SETMASTER) tgt.Master = none;
    if (flags&CPXF_SETTRACER) tgt.Tracer = none;
  } else {
    if (flags&CPXF_SETTARGET) Target = none;
    if (flags&CPXF_SETMASTER) Master = none;
    if (flags&CPXF_SETTRACER) Tracer = none;
  }

  distance = fmax(0.1, distance);

  if (!specified_count) count = 1;
  if (count < 1) return false; // oops
  if (!classname) return false; // oops

  EntityEx bestent = none;
  float bestdist = (flags&CPXF_FARTHEST ? -1 : float.max);

  Entity ee;
  foreach RadiusThings(out ee, tgt.Origin, distance) {
    EntityEx ent = EntityEx(ee);
    if (!ent) continue;
    // k8: is this right?
    if (flags&CPXF_COUNTDEAD) {
      // nothing to do
    } else if (flags&CPXF_DEADONLY) {
      if (ent.bMonster && !ent.bCorpse) continue;
    } else {
      if (ent.bMonster && ent.bCorpse) continue;
    }
    // check class match
    if (nameicmp(GetClassName(ent.Class), classname) != 0) {
      if (!(flags&CPXF_ANCESTOR)) continue;
      class!EntityEx tc = class!EntityEx(ent.Class);
      bool found = false;
      while (tc) {
        if (nameicmp(GetClassName(tc), classname) == 0) { found = true; break; }
        tc = class!EntityEx(GetClassParent(tc));
      }
      if (!found) continue;
    }
    // check distance (save it, we may need it later)
    float dist = (flags&CPXF_NOZ ? tgt.DistTo2(ent) : tgt.DistTo(ent));
    if (dist > distance) continue;
    // check LOS
    if (flags&CPXF_CHECKSIGHT) {
      if (!tgt.CanSee(ent, disableBetterSight:true)) continue;
    }
    // count things
    --count;
    // early exit, if possible
    if (count < 0 && (flags&(CPXF_EXACT|CPXF_LESSOREQUAL))) return false; // oops, too many
    // if we want it to be saved with a distance condition, we cannot exit early
    if ((flags&(CPXF_SETTARGET|CPXF_SETMASTER|CPXF_SETTRACER)) && (flags&(CPXF_FARTHEST|CPXF_CLOSEST))) {
      if (flags&CPXF_FARTHEST) {
        if (dist <= bestdist) continue;
      } else {
        // closest
        if (dist >= bestdist) continue;
      }
      bestent = ent;
      bestdist = dist;
    } else {
      if (!bestent) bestent = ent; // take first one
      // early exit, if possible
      if (count == 0 && !(flags&(CPXF_LESSOREQUAL|CPXF_EXACT))) break;
    }
  }

  if (!bestent) return false; // nothing was found, oops

  // check condition
  if (flags&CPXF_EXACT) {
    if (count != 0) return false;
  } else if (flags&CPXF_LESSOREQUAL) {
    if (count < 0) return false;
  }

  // set pointers
  if (flags&(CPXF_SETTARGET|CPXF_SETMASTER|CPXF_SETTRACER)) {
    if (flags&CPXF_SETONPTR) {
      //k8: is this right?
      if (flags&CPXF_SETTARGET) tgt.Target = bestent;
      if (flags&CPXF_SETMASTER) tgt.Master = bestent;
      if (flags&CPXF_SETTRACER) tgt.Tracer = bestent;
    } else {
      if (flags&CPXF_SETTARGET) Target = bestent;
      if (flags&CPXF_SETMASTER) Master = bestent;
      if (flags&CPXF_SETTRACER) Tracer = bestent;
    }
  }

  return true;
}


//==========================================================================
//
//  A_CheckProximity
//
//==========================================================================
[decorate] final void A_CheckProximity (state Label, name classname, float distance, optional int count, optional int flags, optional int aptr) {
  KeepChainResult();
  if (do_CheckProximity(classname, distance, count!optional, flags!optional, aptr!optional)) {
    DoJump(Label);
  }
}
