//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id$
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

//**************************************************************************
//  Spawn functions
//**************************************************************************

//  Flags for A_SpawnItemEx
const int SXF_TRANSFERTRANSLATION = 1;
const int SXF_ABSOLUTEPOSITION    = 2;
const int SXF_ABSOLUTEANGLE     = 4;
const int SXF_ABSOLUTEMOMENTUM    = 8;
const int SXF_ABSOLUTEVELOCITY    = 8; // "momentum" is deprecated by gozzo
const int SXF_SETMASTER       = 16;
const int SXF_NOCHECKPOSITION   = 32;
const int SXF_TELEFRAG        = 64;
const int SXF_CLIENTSPAWN     = 128;  // only used by Skulltag
const int SXF_CLIENTSIDE      = 128;  // only used by Skulltag
const int SXF_TRANSFERAMBUSHFLAG  = 256;
const int SXF_TRANSFERPITCH     = 512;
const int SXF_TRANSFERPOINTERS    = 1024;
const int SXF_USEBLOODCOLOR = 1 << 11;
const int SXF_CLEARCALLERTID = 1 << 12;
const int SXF_MULTIPLYSPEED = 1 << 13;
const int SXF_TRANSFERSCALE = 1 << 14;
const int SXF_TRANSFERSPECIAL = 1 << 15;
const int SXF_CLEARCALLERSPECIAL = 1 << 16;
const int SXF_TRANSFERSTENCILCOL = 1 << 17;
const int SXF_TRANSFERALPHA = 1 << 18;
const int SXF_TRANSFERRENDERSTYLE = 1 << 19;
const int SXF_SETTARGET = 1 << 20;
const int SXF_SETTRACER = 1 << 21;
const int SXF_NOPOINTERS = 1 << 22;
const int SXF_ORIGINATOR = 1 << 23;
const int SXF_TRANSFERSPRITEFRAME = 1 << 24;
const int SXF_TRANSFERROLL = 1 << 25;
const int SXF_ISTARGET = 1 << 26;
const int SXF_ISMASTER = 1 << 27;
const int SXF_ISTRACER = 1 << 28;


//==========================================================================
//
//  A_TossGib
//
//==========================================================================

final void A_TossGib()
{
  EntityEx gib;
  float an;
  float speed;
  class!EntityEx tp;

  if (bNoBlood)
  {
    tp = Junk;
  }
  else
  {
    tp = Meat;
  }
  gib = Spawn(tp, Origin + vector(0.0, 0.0, 24.0));
  if (!gib)
  {
    return;
  }

  an = Random() * 360.0;
  gib.Angles.yaw = an;
  speed = Random() * 16.0 * 35.0;
  gib.Velocity.x = speed * cos(an);
  gib.Velocity.y = speed * sin(an);
  gib.Velocity.z = Random() * 16.0 * 35.0;
}

//==========================================================================
//
//  A_SpawnDebris
//
//==========================================================================

final void A_SpawnDebris(class!Actor SpawnType, optional bool TransTransl,
  optional float MultH, optional float MultV)
{
  if (!SpawnType)
  {
    return;
  }
  if (MultH <= 0.0)
  {
    MultH = 1.0;
  }
  if (MultV <= 0.0)
  {
    MultV = 1.0;
  }

  int i;
  for (i = 0; i < SpawnType.default.Health; i++)
  {
    EntityEx A = Spawn(SpawnType, Origin + vector((Random() - 0.5) * 16.0,
      (Random() - 0.5) * 16.0, Random() * Height));
    if (A && TransTransl)
    {
      A.Translation = Translation;
    }
    //  The way it uses states sucks big time.
    if (A && i < GetClassNumOwnedStates(SpawnType))
    {
      A.SetState(GetStatePlus(GetClassFirstState(SpawnType), i));
      A.Velocity.x = MultH * (Random() - Random()) * 4.0 * 35.0;
      A.Velocity.y = MultH * (Random() - Random()) * 4.0 * 35.0;
      A.Velocity.z = MultV * (Random() * 8.0 + 5.0) * 35.0;
    }
  }
}

//==========================================================================
//
//  InitSpawnedItem
//
//==========================================================================

final void InitSpawnedItem(EntityEx A, bool TransTransl, bool SetMaster,
  bool NoCheckPos, bool Telestomp, bool TransPitch, bool TransPointers,
  optional bool Originator, optional bool RememberParent)
{
  if (!A)
  {
    return;
  }

  if (TransTransl && !bDontTranslate)
  {
    A.Translation = Translation;
  }

  if (TransPointers)
  {
    A.Target = Target;
    A.Master = Master; // This will be overridden later if SIXF_SETMASTER is set
    A.Tracer = Tracer;
  }

  if (TransPitch)
  {
    A.Angles.pitch = Angles.pitch;
  }

  //  Find instigator for missiles.
  EntityEx Instig = self;
  if (!Originator) {
    while (Instig && Instig.IsMissile(true)) Instig = Instig.Target;
  }

  if (RememberParent && Instig) {
    //??? (Instig ? Instig : self);
#ifdef VC_SCRIPT_USE_SPAWNED_CHILDREN_ARRAY
    bool found = false;
    foreach (auto idx; 0..Instig.SpawnedChildren.length) {
      if (!Instig.SpawnedChildren[idx]) {
        Instig.SpawnedChildren[idx] = A;
        found = true;
        break;
      }
    }
    if (!found) Instig.SpawnedChildren[$] = A;
    //print("SPAWN: `%C` is registered as parent of `%C`", Instig, A);
    foreach (auto idx; 0..Instig.SpawnedChildren.length) print("  child #%d: `%C`", idx, Instig.SpawnedChildren[idx]);
#else
    //print("SPAWN: `%C` is registered as parent of `%C`", Instig, A);
    A.SpawnParent = Instig;
#endif
  }

  if (Telestomp)
  {
    A.TeleportMove(A.Origin, true);
    //  We need this, because otherwise nothing will be spawned if
    // something was telestomped.
    NoCheckPos = true;
  }

  if (A.bMonster)
  {
    //  Check if thing fits in it's current location.
    if (!NoCheckPos && !A.TestLocation())
    {
      if (A.CountsAsKill())
      {
        Level.TotalKills--;
      }
      A.Destroy();
      //  Set result for state chain calls.
      if (XLevel.StateCall)
      {
        XLevel.StateCall->Result = false;
      }
      return;
    }

    if (Instig)
    {
      if (Instig.bMonster)
      {
        A.CopyFriendliness(self, true);
        if (SetMaster)
        {
          A.Master = self;
        }
      }
      else if (Instig.bIsPlayer)
      {
        //  Make monster friendly.
        A.bFriendly = true;
        EntityEx Atk = PlayerEx(Instig.Player).Attacker;
        if (Atk && !Atk.bFriendly)
        {
          //  Make it attack monster who last attacked player.
          A.LastHeard = Atk;
          A.Target = Atk;
        }
      }
    }
  }
  else if (!TransPitch)
  {
    //  For missiles or anything else set target to instigator.
    if (!Instig)
    {
      Instig = self;
    }
    A.Target = Instig;
  }
}

//==========================================================================
//
//  A_SpawnItem
//
//==========================================================================

final void A_SpawnItem(class!Actor ItemType, optional float Distance,
  optional float ZHeight, optional bool UseAmmo, optional bool TransTransl)
{
  if (!specified_UseAmmo)
  {
    UseAmmo = true;
  }

  if (!ItemType)
  {
    if (XLevel.StateCall)
    {
      XLevel.StateCall->Result = false;
    }
    return;
  }

  //  Don't spawn monsters if this actor has been massacred
  if (nameicmp(DamageType, 'Massacre') == 0 && ItemType.default.bMonster)
  {
    return;
  }

  if (!Distance)
  {
    Distance = Radius + ItemType.default.Radius;
  }

  //  If called from weapon, then use ammo.
  if (bIsPlayer &&
    (XLevel.CallingState == Player.ViewStates[ps_weapon].State ||
    XLevel.CallingState == Player.ViewStates[ps_flash].State))
  {
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn)
    {
      return;
    }
    if (UseAmmo && !Wpn.DepleteAmmo(Wpn.FireMode))
    {
      return;
    }
  }

  EntityEx A = Spawn(ItemType, Origin + vector(Distance * cos(Angles.yaw),
    Distance * sin(Angles.yaw), ZHeight - FloorClip));
  InitSpawnedItem(A, TransTransl, UseAmmo, false, false, false, false);
}

//==========================================================================
//
//  A_SpawnItemEx
//
//==========================================================================

final bool A_SpawnItemEx (class!Actor ItemType,
  optional float XOffs, optional float YOffs, optional float ZOffs,
  optional float XVel, optional float YVel, optional float ZVel,
  optional float Angle, optional int Flags, optional int Chance,
  optional int newtid)
{
  if (!ItemType) {
    if (XLevel.StateCall) XLevel.StateCall->Result = false;
    return false;
  }

  if (Chance > 0 && P_Random() < Chance) return true; // per wiki

  // don't spawn monsters if this actor has been massacred (???)
  if (nameicmp(DamageType, 'Massacre') == 0 && ItemType.default.bMonster) return false;

  if (!(Flags&SXF_ABSOLUTEANGLE)) Angle += Angles.yaw;

  TVec Org = vector(XOffs, YOffs, ZOffs-FloorClip);
  if (!(Flags&SXF_ABSOLUTEPOSITION)) {
    // in relative mode negative y values mean 'left' and positive ones
    // mean 'right'. This is the inverse orientation of the absolute mode!
    Org.y = -Org.y;
    VectorRotateAroundZ(ref Org, Angle);
  }
  Org += Origin;

  EntityEx A = Spawn(ItemType, Org);
  InitSpawnedItem(A,
    !!(Flags&SXF_TRANSFERTRANSLATION),
    !!(Flags&SXF_SETMASTER),
    !!(Flags&SXF_NOCHECKPOSITION),
    !!(Flags&SXF_TELEFRAG),
    !!(Flags&SXF_TRANSFERPITCH),
    !!(Flags&SXF_TRANSFERPOINTERS),
    Originator:!!(Flags&SXF_ORIGINATOR),
    RememberParent:true);

  if (A) {
    A.Velocity.x = fclamp(XVel*35.0, -1024, 1024);
    A.Velocity.y = fclamp(YVel*35.0, -1024, 1024);
    A.Velocity.z = fclamp(ZVel*35.0, -1024, 1024);
    A.Angles.yaw = Angle;
    if (!(Flags&SXF_ABSOLUTEVELOCITY)) {
      // the same issue as with offsets
      A.Velocity.y = -A.Velocity.y;
      VectorRotateAroundZ(ref A.Velocity, Angle);
    }
    //print("SPAWN '%C': vel=(%s,%s,%s); A.Velocity=%s", A, XVel, YVel, ZVel, A.Velocity);

    if (Flags&SXF_NOPOINTERS) { A.Master = none; A.Target = none; A.Tracer = none; }

    if (Flags&SXF_TRANSFERAMBUSHFLAG) A.bAmbush = bAmbush;
    if (Flags&SXF_CLEARCALLERTID) SetTID(0);
    if (Flags&SXF_MULTIPLYSPEED) { A.Velocity.x *= A.Speed; A.Velocity.y *= A.Speed; A.Velocity.z *= A.Speed; }
    if (Flags&SXF_TRANSFERSCALE) { A.ScaleX = ScaleX; A.ScaleY = ScaleY; }
    if (Flags&SXF_TRANSFERALPHA) A.Alpha = Alpha;
    if (Flags&SXF_TRANSFERRENDERSTYLE) A.RenderStyle = RenderStyle;
    if (Flags&SXF_SETTARGET) A.Target = self;
    if (Flags&SXF_SETTRACER) A.Tracer = self;
    if (Flags&SXF_SETMASTER) A.Master = self;
    if (Flags&SXF_TRANSFERROLL) A.Angles.roll = Angles.roll;
    if (Flags&SXF_ISTARGET) Target = A;
    if (Flags&SXF_ISMASTER) Master = A;
    if (Flags&SXF_ISTRACER) Tracer = A;
    if (Flags&SXF_TRANSFERSPECIAL) { A.Special = Special; foreach (auto f; 0..Args.length) A.Args[f] = Args[f]; }
    if (Flags&SXF_CLEARCALLERSPECIAL) { Special = 0; foreach (auto f; 0..Args.length) Args[f] = 0; }
    if (specified_newtid && newtid >= 0) A.SetTID(newtid);
    return true;
  }

  return false;
}
