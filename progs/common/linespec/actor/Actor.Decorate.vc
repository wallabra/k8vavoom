//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2021 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
//**
//**  Class for Actor state action methods.
//**
//**************************************************************************

//**************************************************************************
//  Debug log
//**************************************************************************

//==========================================================================
//
//  A_k8ConLog
//
//==========================================================================
[decorate] final void decorate_A_k8ConLog (string msg) {
  printdebug("%C:%s: DECORATE: %s", self, UniqueId, msg);
}


//==========================================================================
//
//  DoRespawn
//
//  needed for `Inventory`
//
//==========================================================================
bool DoRespawn () {
  return true;
}


//===========================================================================
//
//  DoFireRailgun
//
//===========================================================================
protected final void DoFireRailgun (float Offset) {
  if (!bIsPlayer) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (Wpn) {
    if (!Wpn.DepleteAmmo(Wpn.FireMode, default, 1)) return;
    Player.SetViewObject(Wpn);
    if (!(P_Random()&1)) {
      Player.SetViewState(PS_FLASH, Wpn.FindState('Flash'));
    } else {
      Player.SetViewState(PS_FLASH, GetStatePlus(Wpn.FindState('Flash'), 1));
    }
    Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn) return;
  }
  int RailDamage = (Level.Game.deathmatch ? 100 : 150);
  TVec Dir;
  AngleVector(Angles, out Dir);
  RailAttack(Dir, Offset, RailDamage);
}


//===========================================================================
//
//  doFireMissileProjectile
//
//  `A_FireCustomMissile()` and `A_FireProjectile()` are the same thing, so
//  they both will use this code
//
//===========================================================================
protected final void doFireMissileProjectile (class!Actor aMissileType, optional float Angle,
  optional bool UseAmmo, optional float SpawnXY, optional float SpawnZ,
  optional int Flags, optional float Pitch, optional float SpawnFwd)
{
  if (!aMissileType || !bIsPlayer) return;

  if (!specified_UseAmmo) UseAmmo = true;

  name decal = ''; // default
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (UseAmmo) {
    if (!Wpn) return;
    if (!Wpn.DepleteAmmo(Wpn.FireMode)) return;
  }
  if (Wpn) decal = Wpn.DecalName;

  TVec ShootOrg = Origin;
  if (SpawnXY) {
    float s, c;
    sincos(Angles.yaw-90.0, out s, out c);
    ShootOrg.x += SpawnXY*c;
    ShootOrg.y += SpawnXY*s;
  }
  if (SpawnFwd) {
    float s, c;
    sincos(Angles.yaw, out s, out c);
    ShootOrg.x += SpawnFwd*c;
    ShootOrg.y += SpawnFwd*s;
  }
  ShootOrg.z += SpawnZ;

  float ShootAngle = Angles.yaw;
  if (Flags&FPF_AIMATANGLE) ShootAngle += Angle;
  // temporarily adjusts the pitch
  float SavedPitch = Angles.pitch;
  if (Flags&FPF_NOAUTOAIM) Angles.pitch += Pitch; // `A_FireCustomMissile()` does this another way

  EntityEx AimTarget;
  EntityEx A = SpawnPlayerMissileEx(aMissileType, false, AimTarget, ShootAngle, ShootOrg, decal, noAutoAim:!!(Flags&FPF_NOAUTOAIM));
  Angles.pitch = SavedPitch;

  if (A) {
    if (Flags&FPF_TRANSFERTRANSLATION) A.CopyTranslations(self);
    // handle seeker missiles
    if (A.bSeekerMissile) A.Tracer = AimTarget;
    if (!(Flags&FPF_AIMATANGLE)) VectorRotateAroundZ(ref A.Velocity, Angle);
  }
}


//**************************************************************************
//  Weapon functions
//**************************************************************************

//===========================================================================
//
//  do_A_GunFlash
//
//  GFF_NOEXTCHANGE is 1
//
//===========================================================================
protected final void do_A_GunFlash (optional name newstate, optional int flags) self(Actor) {
  if (!bIsPlayer) return;

  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (!Wpn) return; // just in case

  if (!(flags&1) && MeleeState) {
    SetState(MeleeState);
    Wpn = PlayerEx(Player).ReadyWeapon;
    if (!Wpn) return;
  }

  state flashState;
  if (!specified_newstate) {
    if (Wpn.FireMode == Weapon::FIRE_Secondary) flashState = Wpn.FindState('AltFlash');
    if (!flashState) flashState = Wpn.FindState('Flash');
  } else {
    flashState = Wpn.FindState(newstate);
  }

  Player.SetViewObject(Wpn);
  Player.SetViewState(PS_FLASH, flashState);
}


//===========================================================================
//
//  do_A_CheckReload
//
//===========================================================================
protected final void do_A_CheckReload () self(Actor) {
  if (!bIsPlayer) return;
  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (Wpn) Wpn.CheckAmmo(Wpn.FireMode, AutoSwitch:true);
}


//===========================================================================
//
//  do_A_ReFire
//
//  The player can re-fire the weapon without lowering it entirely.
//
//===========================================================================
protected final void do_A_ReFire (optional state refirestate) self(Actor) {
  if (!bIsPlayer) return;

  // we have to explicitly set the weapon state here due to standard weapon definitions
  // RocketLauncher, for example, has zero-duration refire state
  // our WatchCat will take care of endless loops

  PlayerEx pex = PlayerEx(Player);
  if (!pex) return; // just in case

  Weapon Wpn = pex.ReadyWeapon;

  if (!Wpn) {
    pex.ResetWeaponReloadRefire();
    if (!pex.PendingWeapon && Player.MO.Health > 0) {
      Wpn.CheckAmmo(Wpn.FireMode, AutoSwitch:true); // k8: should we switch weapon here?
    }
    return;
  }

  if (!pex.PendingWeapon && Player.MO.Health > 0) {
    if (Wpn.FireMode == Weapon::FIRE_Primary && (Player.Buttons&BT_ATTACK)) {
      pex.ResetPlayerFiringState();
      ++pex.Refire;
      pex.FireWeapon(refirestate!optional);
      return;
    }

    if (Wpn.FireMode == Weapon::FIRE_Secondary && (Player.Buttons&BT_ALT_ATTACK)) {
      pex.ResetPlayerFiringState();
      ++pex.Refire;
      pex.AltFireWeapon(refirestate!optional);
      return;
    }

    pex.Refire = 0;
    //k8: do we need to check ammo here at all?
    Wpn.CheckAmmo(Wpn.FireMode, AutoSwitch:true); // k8: should we switch weapon here?
  }
}


//==========================================================================
//
//  do_A_Raise
//
//==========================================================================
protected final void do_A_Raise (optional float raisespeed) self(Actor) {
  if (!bIsPlayer) return;

  Weapon Wpn = PlayerEx(Player).ReadyWeapon;
  if (!Wpn) return;
  Wpn.bBobDisabled = true;

  if (!specified_raisespeed) raisespeed = Weapon::RAISESPEED;
  if (raisespeed <= 0) raisespeed = Weapon::RAISESPEED; //k8: sanity guard

  //print("RAISING %C: curr=%s; top=%s; bot=%s; speed=%s; time=%s", Wpn, Player.ViewStates[PS_WEAPON].SY, Weapon::WEAPONTOP, Weapon::WEAPONBOTTOM, raisespeed, Player.ViewStates[PS_WEAPON].StateTime);

  float prevsy = Player.ViewStates[PS_WEAPON].SY;

  Player.PSpriteWeaponLoweringStartTime = 0;
  Player.PSpriteWeaponLoweringDuration = 0;
  Player.PSpriteWeaponLowerPrev = prevsy;

  // FIXME!!
  /*
  if (Level.Game.frametime < 1.0/35.0) {
    Player.ViewStates[PS_WEAPON].SY -= raisespeed;
  } else {
    Player.ViewStates[PS_WEAPON].SY -= raisespeed*35.0*Level.Game.frametime;
  }
  */
  float sy = prevsy-raisespeed;
  Player.SetViewStateOffsets(0, sy);

  if (sy > Weapon::WEAPONTOP) {
    // not raised all the way yet
    Player.PSpriteWeaponLoweringStartTime = XLevel.Time;
    Player.PSpriteWeaponLoweringDuration = Player.ViewStates[PS_WEAPON].StateTime;
    return;
  }

  if (prevsy > Weapon::WEAPONTOP) {
    // raise last time
    Player.PSpriteWeaponLoweringStartTime = XLevel.Time;
    Player.PSpriteWeaponLoweringDuration = Player.ViewStates[PS_WEAPON].StateTime;
  }

  Player.SetViewStateOffsets(0, Weapon::WEAPONTOP);
  Player.SetViewObject(Wpn);
  if (Wpn) {
    Player.SetViewState(PS_WEAPON, Wpn.GetReadyState());
  } else {
    Player.SetViewState(PS_WEAPON, none);
  }
}


//==========================================================================
//
//  do_A_Lower
//
//  Lowers current weapon, and changes weapon at bottom.
//
//==========================================================================
protected final void do_A_Lower (optional float lowerspeed) self(Actor) {
  if (!bIsPlayer) return;

  Weapon ready = PlayerEx(Player).ReadyWeapon;
  Weapon pending = PlayerEx(Player).PendingWeapon;

  if (ready) ready.bBobDisabled = true;
  if (pending) pending.bBobDisabled = true;

  /*
  if (ready && ready == pending) {
    if (Player.PlayerState != PST_DEAD &&
        Player.MO == self && // voodoo doll
        !Player.bIsBot)
    {
      print("%C: LOWERING UNRAISED WEAPON! (3)", self);
    }
  }
  */

  if (!specified_lowerspeed) lowerspeed = Weapon::LOWERSPEED;
  if (lowerspeed <= 0) lowerspeed = Weapon::LOWERSPEED; //k8: sanity guard

  float prevsy = Player.ViewStates[PS_WEAPON].SY;

  Player.PSpriteWeaponLoweringStartTime = 0;
  Player.PSpriteWeaponLoweringDuration = 0;
  Player.PSpriteWeaponLowerPrev = prevsy;

  if (PlayerEx(Player).MorphTime || PlayerEx(Player).bInstantWeaponSwitch) {
    Player.SetViewStateOffsets(0, Weapon::WEAPONBOTTOM);
    prevsy = Weapon::WEAPONBOTTOM;
  } else {
    // FIXME!!
    /*
    if (Level.Game.frametime < 1.0/35.0) {
      Player.ViewStates[PS_WEAPON].SY += lowerspeed;
    } else {
      Player.ViewStates[PS_WEAPON].SY += lowerspeed*35.0*Level.Game.frametime;
    }
    */
    Player.SetViewStateOffsets(0, lowerspeed, delta:true);
  }

  float sy = Player.ViewStates[PS_WEAPON].SY;

  if (sy < Weapon::WEAPONBOTTOM) {
    // not lowered all the way yet
    Player.PSpriteWeaponLoweringStartTime = XLevel.Time;
    Player.PSpriteWeaponLoweringDuration = Player.ViewStates[PS_WEAPON].StateTime;
    return;
  }

  if (Player.PlayerState == PST_DEAD) {
    // player is dead, so don't bring up a pending weapon
    Player.SetViewStateOffsets(0, Weapon::WEAPONBOTTOM);
    return;
  }

  if (Player.MO.Health <= 0) {
    // player is dead, so keep the weapon off screen
    Player.SetViewObject(none);
    Player.SetViewState(PS_WEAPON, none);
    return;
  }

  if (prevsy < Weapon::WEAPONTOP) {
    // lower last time
    Player.PSpriteWeaponLoweringStartTime = XLevel.Time;
    Player.PSpriteWeaponLoweringDuration = Player.ViewStates[PS_WEAPON].StateTime;
  }

  // clear flash state, needed for Strife
  Player.SetViewState(PS_FLASH, none);

  if (!pending) {
    PlayerEx(Player).SetWeapon(none);
    if (Player.PlayerState == PST_DEAD) return;
    if (Player.MO != self) return; // voodoo doll
    if (Player.bIsBot) return;
    print("%C: LOWERING UNRAISED WEAPON! (2)", self);
    return;
  }

  PlayerEx(Player).SetWeapon(pending/*PlayerEx(Player).PendingWeapon*/);
  PlayerEx(Player).BringUpWeapon();
}


//**************************************************************************
//  State jumps
//**************************************************************************

//==========================================================================
//
//  A_RetDoJump
//
//==========================================================================
[decorate] final void decorate_A_RetDoJump (state aState) {
  KeepChainResult(); //k8: this is prolly wrong, because `return` in GZDoom can return `fail` condition too
  if (XLevel.StateCall) {
    XLevel.StateCall->State = aState;
  } else {
    if (bIsPlayer) {
      foreach (int xidx; 0..NUMPSPRITES) {
        if (XLevel.CallingState == Player.ViewStates[xidx].State) {
          Player.SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
          Player.SetViewState(xidx, aState);
          return;
        }
      }
    }
    SetState(aState);
  }
}


//**************************************************************************
//  Args
//**************************************************************************

//==========================================================================
//
//  decorate_GetArg
//
//==========================================================================
[decorate] final int decorate_GetArg (int n) {
  return (n >= 0 && n < 5 ? Args[n] : 0);
}


//==========================================================================
//
//  A_SetArg
//
//==========================================================================
[decorate] final void A_SetArg (int n, int v) {
  if (n >= 0 && n < 5) Args[n] = v;
}


//**************************************************************************
//  Various getters and setters
//**************************************************************************

//==========================================================================
//
//  A_SetAngle
//
//==========================================================================
[decorate] final void A_SetAngle (float newyaw, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetAngle', aptr!optional);
  if (!tgt) return;
  tgt.Angles.yaw = AngleMod360(newyaw);
}


//==========================================================================
//
//  A_Turn
//
//==========================================================================
[decorate] final void A_Turn (float yawdelta) {
  Angles.yaw = AngleMod360(Angles.yaw+yawdelta);
}


//==========================================================================
//
//  A_SetSpeed
//
//==========================================================================
[decorate] final void A_SetSpeed (float aspeed, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SetSpeed', aptr!optional));
  if (!tgt) return;
  if (!aspeed.isfinite) aspeed = 0;
  tgt.Speed = fmax(0, aspeed)*35.0;
}


//==========================================================================
//
//  A_SetFloatSpeed
//
//==========================================================================
[decorate] final void A_SetFloatSpeed (float aspeed, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SetFloatSpeed', aptr!optional));
  if (!tgt) return;
  if (!aspeed.isfinite) aspeed = 0;
  tgt.FloatSpeed = fmax(0, aspeed)*35.0;
}


//==========================================================================
//
//  A_SetPainThreshold
//
//==========================================================================
[decorate] final void A_SetPainThreshold (int athreshold, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SetPainThreshold', aptr!optional));
  if (!tgt) return;
  tgt.PainThreshold = athreshold;
}


//==========================================================================
//
//  A_SetRenderStyle
//
//==========================================================================
[decorate] final void A_SetRenderStyle (float aalpha, int style) {
  Alpha = fclamp(aalpha, 0.0, 1.0);
  RenderStyle = style;
}


//==========================================================================
//
//  A_SetMass
//
//==========================================================================
[decorate] final void A_SetMass (float newmass) {
  Mass = (newmass.isfinite ? fclamp(newmass, 0, 10000) : 10000);
}


/*
const int SPF_FORCECLAMP = 0x01;
const int SPF_INTERPOLATE = 0x00;
*/

//==========================================================================
//
//  clampPitch
//
//==========================================================================
private final float clampPitch (float newpitch) {
  // hack, so player head won't be clamped down
  //print("  A_SetPitch00: newpitch=%f", newpitch);
  if (newpitch >= 360) {
    newpitch = AngleMod360(newpitch);
    //print("  A_SetPitch01: newpitch=%f", newpitch);
  }
  if (newpitch > 180) newpitch = AngleMod360(newpitch)-360; // [-90..]
  //print("  A_SetPitch02: newpitch=%f", newpitch);
  //return fclamp(newpitch, -90.0, 90.0);
  return fclamp(newpitch, -80.0, 80.0); // actual engine limits
}


//==========================================================================
//
//  A_SetPitch
//
//  should be always clamped on player
//
//==========================================================================
[decorate] final void A_SetPitch (float newpitch, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetPitch', aptr!optional);
  if (!tgt) return;
  if (tgt.bIsPlayer || (flags&0x01) != 0) newpitch = clampPitch(newpitch);
  tgt.Angles.pitch = /*AngleMod360*/(newpitch);
}


//==========================================================================
//
//  A_SetRoll
//
//==========================================================================
[decorate] final void A_SetRoll (float newroll, optional int flags, optional int aptr) {
  Entity tgt = DecorDoAAPtr('A_SetRoll', aptr!optional);
  if (!tgt) return;
  tgt.Angles.roll = AngleMod360(newroll);
}


//**************************************************************************
//  ACS
//**************************************************************************

//==========================================================================
//
//  ACS_Execute
//
//==========================================================================
[decorate] final bool ACS_Execute (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteAlways
//
//==========================================================================
[decorate] final bool ACS_ExecuteAlways (int script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_ExecuteWithResult
//
//==========================================================================
[decorate] final int ACS_ExecuteWithResult (int script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecute
//
//==========================================================================
[decorate] final bool ACS_NamedExecute (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACS(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteAlways
//
//==========================================================================
[decorate] final bool ACS_NamedExecuteAlways (string script, optional int map, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  //print("ACS_NamedExecuteAlways: script=%s; map=%d; args=(%d,%d,%d,%d)", script, map, s_arg1, s_arg2, s_arg3, s_arg4);
  return XLevel.RunNamedACSAlways(self, script, map, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  ACS_NamedExecuteWithResult
//
//==========================================================================
[decorate] final int ACS_NamedExecuteWithResult (string script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//==========================================================================
//
//  CallACS
//
//==========================================================================
[decorate] final int CallACS (string script, optional int s_arg1, optional int s_arg2, optional int s_arg3, optional int s_arg4) {
  return XLevel.RunNamedACSWithResult(self, script, s_arg1, s_arg2, s_arg3, s_arg4);
}


//**************************************************************************
//  Misc
//**************************************************************************

//==========================================================================
//
//  decorate_CountInv
//
//==========================================================================
[decorate] final int decorate_CountInv (name ItemName, optional int aptr) {
  Entity tgt = DecorDoAAPtr('decorate_CountInv', aptr!optional);
  if (!tgt) return 0;
  return tgt.CheckInventory(ItemName, allowReplacement:false, fromACS:false); //k8: is it?
}


//==========================================================================
//
//  decorate_G_SkillPropertyInt
//
//==========================================================================
[decorate] final int decorate_G_SkillPropertyInt (int prop) {
  switch (prop) {
    case SKILLP_FastMonsters: return Level.World.bSkillFastMonsters;
    case SKILLP_Respawn: printwarn("G_SkillPropertyInt: respawn time is not implemented!"); return 0;
    case SKILLP_RespawnLimit: return Level.World.GetRespawnLimit();
    case SKILLP_DisableCheats: return false;
    case SKILLP_AutoUseHealth: return Level.World.bSkillAutoUseHealth;
    case SKILLP_SpawnFilter: return Level.World.GetSpawnFilter();
    case SKILLP_EasyBossBrain: return Level.World.bSkillEasyBossBrain;
    case SKILLP_ACSReturn: return Level.World.SkillAcsReturn;
    case SKILLP_NoPain: return false;
    case SKILLP_EasyKey: return 0;
    case SKILLP_SlowMonsters: return Level.World.bSkillSlowMonsters;
    case SKILLP_Infight: return (Level.Infighting ? Level.Infighting : GetCvarI('infighting'));
    case SKILLP_PlayerRespawn: return 0;
  }
  return 0;
}


//==========================================================================
//
//  decorate_G_SkillPropertyFloat
//
//==========================================================================
[decorate] final float decorate_G_SkillPropertyFloat (int prop) {
  switch (prop) {
    case SKILLP_AmmoFactor: return Level.World.GetAmmoFactor();
    case SKILLP_DropAmmoFactor: return 1.0;
    case SKILLP_ArmorFactor: return 1.0;
    case SKILLP_HealthFactor: return 1.0;
    case SKILLP_DamageFactor: return 1.0;
    case SKILLP_Aggressiveness: return Level.World.GetAggressiveness();
    case SKILLP_MonsterHealth: return 1.0;
    case SKILLP_FriendlyHealth: return 1.0;
    case SKILLP_KickbackFactor: return 1.0;
  }
  return 0.0;
}


//==========================================================================
//
//  decorate_GetZAt
//
//==========================================================================
//[float x[, float y[, float angle[, int flags[, int pick_pointer]]]]]
[decorate] final float decorate_GetZAt (optional float x, optional float y, optional float angle, optional int flags, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('decorate_GetZAt', aptr!optional));
  if (!tgt) return (flags&GZF_CEILING ? CeilingZ : FloorZ);

  TVec org = tgt.Origin;
  if (flags&GZF_ABSOLUTEPOS) {
    org = vector(x, y);
  } else {
    TAVec ang = tgt.Angles;
    if (!(flags&GZF_ABSOLUTEANG)) ang.yaw += angle;
    ang.pitch = 0;
    ang.roll = 0;
    TVec forward;
    TVec right;
    TVec up;

    AngleVectors(ang, out forward, out right, out up);
    org = tgt.Origin;
    org += forward*x;
    org += right*y;
  }

  if (flags&GZF_NO3DFLOOR) {
    sector_t *sec = XLevel.PointInSector(org);
    if (flags&GZF_CEILING) {
      return GetPointZClamped(ref sec->ceiling, org);
    } else {
      return GetPointZClamped(ref sec->floor, org);
    }
  } else if ((flags&(GZF_CEILING|GZF_3DRESTRICT)) == (GZF_CEILING|GZF_3DRESTRICT)) {
    //k8: this is prolly not right
    sector_t *sec = XLevel.PointInSector(org);
    return GetPointZClamped(ref sec->ceiling, org);
  } else {
    tmtrace_t tmtrace;
    tgt.GetFloorAndCeilingEx(out tmtrace, org, collideWorld:true, collideThings:false);
    return (flags&GZF_CEILING ? tmtrace.CeilingZ : tmtrace.FloorZ);
  }
}


//==========================================================================
//
//  decorate_GetDistance
//
//==========================================================================
//float GetDistance (bool checkz [, int ptr_select])
[decorate] final float decorate_GetDistance (bool checkz, optional int aptr) {
  Entity tgt = DecorDoAAPtr('decorate_GetDistance', aptr!optional);
  if (!tgt) return 0;
  if (tgt == self) return 0;
  return (checkz ? DistTo(tgt) : DistTo2(tgt));
}


//==========================================================================
//
//  decorate_GetAngle
//
//==========================================================================
//float GetAngle (int flags[, int ptr_select])
[decorate] final float decorate_GetAngle (optional int flags, optional int aptr) {
  if (!specified_aptr || aptr == AAPTR_DEFAULT) aptr = AAPTR_TARGET;
  Entity tgt = DecorDoAAPtr('decorate_GetAngle', aptr);
  if (!tgt) return 0;
  if (tgt == self) return 0;
  float ang = (flags&2 ?
    atan2(Origin.y-tgt.Origin.y, Origin.x-tgt.Origin.x) : // from target to self
    atan2(tgt.Origin.y-Origin.y, tgt.Origin.x-Origin.x)); // from self to target
  if (flags&1) {
    // relative
    ang = AngleDiff(ang, (flags&2 ? tgt.Angles.yaw : Angles.yaw));
  }
  return ang;
}


//==========================================================================
//
//  decorate_IsPointerEqual
//
//==========================================================================
[decorate] final bool decorate_IsPointerEqual (optional int aptr0, optional int aptr1) {
  Entity e0 = DecorDoAAPtr('IsPointerEqual', aptr0);
  Entity e1 = DecorDoAAPtr('IsPointerEqual', aptr1);
  return (e0 == e1);
}


//==========================================================================
//
//  A_SpawnProjectile
//
//==========================================================================
[decorate] final void A_SpawnProjectile (name MissileTypeName, optional float SpawnHeight, optional float SpawnXYOffset,
                                         optional float Angle, optional int AimMode, optional float Pitch, optional int aptr)
{
  if (!MissileTypeName) return;
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SpawnProjectile', aptr!optional));
  if (!tgt) return;

  int Flags = AimMode&~3;
  AimMode &= 3;

  class!EntityEx clsMissileType = class!EntityEx(FindClassNoCase(MissileTypeName));
  if (!clsMissileType) return;
  clsMissileType = class!EntityEx(GetClassReplacement(clsMissileType));
  if (!clsMissileType) return;
  //if (Level.Game.nomonsters && clsMissileType.default.bMonster) return;

  if (tgt.Target || AimMode == 2) {
    if (clsMissileType) {
      if (!specified_SpawnHeight) SpawnHeight = 32.0;
      if (!specified_SpawnXYOffset) SpawnXYOffset = 0; // was 1, why?
      TVec Offs = float(SpawnXYOffset)*vector(cos(tgt.Angles.yaw-90.0), sin(tgt.Angles.yaw-90.0), 0.0);
      EntityEx A;

      switch (AimMode) {
        default:
          tgt.Origin += Offs;
          A = tgt.SpawnMissile(tgt.Target, clsMissileType, SpawnHeight);
          tgt.Origin -= Offs;
          break;
        case 1:
          Offs.z = SpawnHeight;
          A = tgt.SpawnMissileXYZ(tgt.Origin+Offs, tgt.Target, clsMissileType);
          break;
        case 2:
          tgt.Origin += Offs;
          A = tgt.SpawnMissileAngles(clsMissileType, tgt.Angles.yaw, Pitch, SpawnHeight);
          tgt.Origin -= Offs;
          break;
      }

      if (A) {
        VectorRotateAroundZ(ref A.Velocity, Angle);
        // find correct shooter for projectiles shooting projectiles
        if (tgt.IsMissile(!!(Flags&4))) {
          EntityEx Own = tgt/*self*/;
          while (Own.IsMissile(!!(Flags&4)) && Own.Target) Own = Own.Target;
          A.Target = Own;
          if (A.bSeekerMissile) A.Tracer = tgt.Tracer;
        } else if (A.bSeekerMissile) {
          A.Tracer = tgt.Target;
        }
      }
    }
  } else if (Flags&8) {
    if (tgt.SeeState) tgt.SetState(tgt.SeeState);
  }
}


//===========================================================================
//
//  A_Quake
//
//===========================================================================
[decorate] final bool A_Quake (float intensity, float ticduration, float damrad, float tremrad, optional name soundname) {
  if (ticduration < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensity < 1) return false;
  intensity = fmin(intensity, 9);
  QuakeFocus focus = SpawnEntityChecked(class!QuakeFocus, QuakeFocus, Origin);
  if (focus) {
    focus.Richters = int(intensity);
    focus.QuakeDuration = int(ticduration)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    //if (soundname) PlaySound(soundname, CHAN_AUTO);
    focus.SoundName = soundname;
    return true;
  }
  return false;
}


//===========================================================================
//
//  A_QuakeEx
//
//  radii are in map units
//
//===========================================================================
[decorate] final bool A_QuakeEx (float intensityX, float intensityY, float intensityZ, float ticduration,
                                 float damrad, float tremrad, optional name soundname, optional int flags,
                                 optional float mulwavex, optional float mulwavey, optional float mulwavez,
                                 optional int falloff, optional int highpoint, optional float rollIntensity,
                                 optional float rollWave)
{
  if (ticduration < 1) return false;
  if (damrad < 1 && tremrad < 1) return false;
  damrad = fmax(0, damrad);
  tremrad = fmax(0, tremrad);
  if (intensityX < 1 && intensityY < 1 && intensityZ < 1) return false;
  intensityX = fmin(intensityX, 9);
  intensityY = fmin(intensityY, 9);
  intensityZ = fmin(intensityZ, 9);
  QuakeFocusEx focus = SpawnEntityChecked(class!QuakeFocusEx, QuakeFocusEx, Origin);
  if (focus) {
    focus.Richters = vector(int(intensityX), int(intensityY), int(intensityZ));
    focus.QuakeDuration = int(ticduration)>>1; // decremented every 2 tics
    focus.DamageRadius = damrad;
    focus.TremorRadius = tremrad;
    //if (soundname) PlaySound(soundname, CHAN_AUTO);
    focus.SoundName = soundname;
    focus.Flags = flags;
    focus.MulWave = vector(mulwavex, mulwavey, mulwavez);
    focus.Falloff = fmax(0, falloff);
    focus.HighPoint = fmax(0, highpoint);
    return true;
  }
  return false;
}


//==========================================================================
//
//  decorate_A_CheckFlag
//
//==========================================================================
[decorate] final void decorate_A_CheckFlag (string flagname, state label, optional int aptr) {
  KeepChainResult();
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFlag', aptr!optional));
  if (!tgt) return;
  //if (!decoDoCheckFlag(flagname, tgt)) return;
  if (!tgt.GetDecorateFlag(flagname)) return;
  DoJump(label);
}


//==========================================================================
//
//  decorate_A_ChangeFlag
//
//==========================================================================
/*
[decorate] final void decorate_A_ChangeFlag (string flagname, int value) {
  //decoDoFlagAction(flagname, self, !!value);
  print("A_ChangeFlag: name=<%s>; value=%s", flagname, value);
  //print("  nopain0=%s", bNoPain);
  decoDoSetFlag(flagname, self, !!value);
  //print("  nopain1=%s", bNoPain);
}
*/


//==========================================================================
//
//  doDamageSomething
//
//  common code for `A_DamageXXX()`
//
//==========================================================================
final void doDamageSomething (EntityEx dest, int amount, name adamagetype, int flags, optional name filter, optional name aspecies,
                              optional int src, optional int inflict)
{
  if (!dest) return;

  if (amount == 0 && !(flags&DMSS_KILL)) return;

  if (!dest.DecorFilterCheck(invertFilter:!!(flags&DMSS_EXFILTER), invertSpecies:!!(flags&DMSS_EXSPECIES), either:!!(flags&DMSS_EITHER), filter:filter!optional, aspecies:aspecies!optional)) return;

  // get source and inflictor
  EntityEx source = EntityEx(DecorDoAAPtr('doDamageSomething', src!optional));
  EntityEx inflictor = EntityEx(DecorDoAAPtr('doDamageSomething', inflict!optional));

  // fix damage type
  if (inflictor && (flags&DMSS_INFLICTORDMGTYPE)) adamagetype = inflictor.DamageType;

  if ((flags&DMSS_KILL) && amount < dest.Health) amount = dest.Health;
  if (amount == 0) return; // just in case

  //DMSS_FOILBUDDHA = 0x00000010 //k8: no wai
  if (amount < 0) {
    // heal
    dest.GiveBody(-amount);
  } else {
    dest.Damage(inflictor:inflictor, source:source, amount, DmgType:adamagetype,
      NoArmor:!(flags&DMSS_AFFECTARMOR),
      forced:!!(flags&DMSS_FOILINVUL),
      ignoreDamageFactors:!!(flags&DMSS_NOFACTOR),
      ignorePowerups:!!(flags&DMSS_NOPROTECT)
    );
  }
}


//==========================================================================
//
//  decorate_A_DamageSelf
//
//==========================================================================
[decorate] final void decorate_A_DamageSelf (int amount, optional name adamagetype, optional int flags,
                                             optional name filter, optional name aspecies, optional int src,
                                             optional int inflict)
{
  doDamageSomething(self, amount, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  decorate_A_DamageTarget
//
//==========================================================================
[decorate] final void decorate_A_DamageTarget (int amount, optional name adamagetype, optional int flags,
                                               optional name filter, optional name aspecies, optional int src,
                                               optional int inflict)
{
  doDamageSomething(Target, amount, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  decorate_A_DamageMaster
//
//==========================================================================
[decorate] final void decorate_A_DamageMaster (int amount, optional name adamagetype, optional int flags,
                                               optional name filter, optional name aspecies, optional int src,
                                               optional int inflict)
{
  doDamageSomething(Master, amount, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  decorate_A_DamageTracer
//
//==========================================================================
[decorate] final void decorate_A_DamageTracer (int amount, optional name adamagetype, optional int flags,
                                               optional name filter, optional name aspecies, optional int src,
                                               optional int inflict)
{
  doDamageSomething(Tracer, amount, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
}


//==========================================================================
//
//  decorate_A_DamageChildren
//
//==========================================================================
[decorate] final void decorate_A_DamageChildren (int amount, optional name adamagetype, optional int flags,
                                                 optional name filter, optional name aspecies, optional int src,
                                                 optional int inflict)
{
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master != self) continue;
    doDamageSomething(A, amount, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
  }
}


//==========================================================================
//
//  decorate_A_DamageSiblings
//
//==========================================================================
[decorate] final void decorate_A_DamageSiblings (int amount, optional name adamagetype, optional int flags,
                                                 optional name filter, optional name aspecies, optional int src,
                                                 optional int inflict)
{
  EntityEx mainMaster = Master;
  if (!mainMaster) return;
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master == mainMaster && A != self) {
      doDamageSomething(A, amount, adamagetype, flags, filter!optional, aspecies!optional, src!optional, inflict!optional);
    }
  }
}


//==========================================================================
//
//  decorate_A_SetTics
//
//==========================================================================
[decorate] final void decorate_A_SetTics (int tics) {
  tics = max(tics, 0);
  StateTime = float(tics)/35.0;
}


//==========================================================================
//
//  decorate_A_CheckFloorTextureGlob
//
//==========================================================================
[decorate] final void decorate_A_CheckFloorTextureGlob (string txname, state label, optional int aptr, optional bool dumpTexture) {
  KeepChainResult();
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_CheckFloorTexture', aptr!optional));
  if (!tgt) return;
  if (!tgt.Sector) return; // just in case
  auto tname = GetTextureName(tgt.Sector.floor.pic);
  if (dumpTexture) print("TEXTURE NAME: <%s> gmatch <%s>: res=%B", tname, txname, globmatch(string(tname), txname, caseSensitive:false));
  if (!globmatch(string(tname), txname, caseSensitive:false)) return;
  DoJump(label);
}


//==========================================================================
//
//  A_DropItem
//
//==========================================================================
[decorate] final void A_DropItem (name item, optional int dropamount, optional int chance) {
  if (!item) return;

  float dropChance = 1;
  if (specified_chance) {
    if (chance <= 0) return;
    if (chance < 256) dropChance = float(chance)/256.0;
  }

  class!EntityEx dip = class!EntityEx(FindClassNoCase(item));
  if (!dip) return;
  dip = class!EntityEx(GetClassReplacement(dip));
  if (!dip) return;

  if (specified_dropamount) {
    if (dip !isa Inventory) dropamount = 1;
  } else {
    dropamount = 1;
  }

  DropItem(dip, dropamount, dropChance);
}


//==========================================================================
//
//  doRemoveSomethingCheck
//
//  common code for `A_RemoveXXX()`
//
//==========================================================================
final bool doRemoveSomethingCheck (EntityEx dest, int flags, optional name filter, optional name aspecies) {
  if (!dest) return false;

  if (!dest.DecorFilterCheck(invertFilter:!!(flags&RMVF_EXFILTER), invertSpecies:!!(flags&RMVF_EXSPECIES), either:!!(flags&RMVF_EITHER), filter:filter!optional, aspecies:aspecies!optional)) return false;

  // check other flags
  if (!(flags&RMVF_EVERYTHING)) {
    if (dest.bMonster) {
      if (flags&RMVF_NOMONSTERS) return false;
    } else if (dest.IsMissile(false)) {
      if (!(flags&RMVF_MISSILES)) return false;
    } else {
      // other?
      if (!(flags&RMVF_MISC)) return false;
    }
  }

  return true;
}


//==========================================================================
//
//  A_Remove
//
//==========================================================================
[decorate] final void A_Remove (int aptr, optional int flags, optional name filter, optional name aspecies) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_Remove', aptr));
  if (!tgt) return;
  if (doRemoveSomethingCheck(tgt, flags, filter!optional, aspecies!optional)) delete tgt;
}


//==========================================================================
//
//  A_RemoveMaster
//
//==========================================================================
[decorate] final void A_RemoveMaster (optional int flags, optional name filter, optional name aspecies) {
  if (doRemoveSomethingCheck(Master, flags, filter!optional, aspecies!optional)) delete Master;
}


//==========================================================================
//
//  A_RemoveTarget
//
//==========================================================================
[decorate] final void A_RemoveTarget (optional int flags, optional name filter, optional name aspecies) {
  if (doRemoveSomethingCheck(Target, flags, filter!optional, aspecies!optional)) delete Target;
}


//==========================================================================
//
//  A_RemoveTracer
//
//==========================================================================
[decorate] final void A_RemoveTracer (optional int flags, optional name filter, optional name aspecies) {
  if (doRemoveSomethingCheck(Tracer, flags, filter!optional, aspecies!optional)) delete Tracer;
}


//==========================================================================
//
//  A_RemoveChildren
//
//==========================================================================
[decorate] final void A_RemoveChildren (optional bool all, optional int flags, optional name filter, optional name aspecies) {
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master != self) continue;
    if (!all && A.Health > 0) continue;
    if (!doRemoveSomethingCheck(A, flags, filter!optional, aspecies!optional)) continue;
    A.Destroy();
  }
}


//==========================================================================
//
//  A_RemoveSiblings
//
//==========================================================================
[decorate] final void A_RemoveSiblings (optional bool all, optional int flags, optional name filter, optional name aspecies) {
  EntityEx mainMaster = Master;
  if (!mainMaster) return;
  Actor A;
  foreach AllThinkers(Actor, A) {
    if (A.Master == mainMaster && A != self) {
      if (!all && A.Health > 0) continue;
      if (!doRemoveSomethingCheck(A, flags, filter!optional, aspecies!optional)) continue;
      A.Destroy();
    }
  }
}


//==========================================================================
//
//  A_RadiusGive
//
//==========================================================================
[decorate] final int A_RadiusGive (name itemname, float distance, int flags, optional int amount,
                                   optional name filter, optional name aspecies, optional float mindist,
                                   optional int limit)
{
  if (!specified_limit) limit = int.max;
  if (limit < 1) return 0;

  if (amount < 0) return 0;
  amount = max(1, amount); // 0 is 1 anyway

  if (distance <= 0) return 0; // as per docs
  if (mindist > distance) return 0;

  // find item class
  if (!itemname) return 0;
  class!Inventory itemtype = class!Inventory(FindClassNoCase(itemname));
  if (!itemtype) return 0;
  /*k8: i don't think so
  itemtype = class!Inventory(GetClassReplacement(itemtype));
  if (!itemtype) return 0;
  */

  bool giveCube = (flags&RGF_CUBE);
  int count = 0;
  Entity enti;
  foreach RadiusThings(enti, Origin, distance*(giveCube ? 2.0 : 1.0)) {
    EntityEx ent = EntityEx(enti);
    if (!ent) continue;

    if (ent == self) {
      if (!(flags&RGF_GIVESELF)) continue;
    } else {
      // check distance
      if (mindist > 0 && length2d(ent.Origin-Origin) > mindist) continue;
      if (giveCube) {
        // additional check for cube giver
        if (fabs(Origin.x-ent.Origin.x) > distance || fabs(Origin.y-ent.Origin.y) > distance) continue;
      }

      if (!ent.DecorFilterCheck(invertFilter:!!(flags&RGF_EXFILTER), invertSpecies:!!(flags&RGF_EXSPECIES), either:!!(flags&RGF_EITHER), filter:filter!optional, aspecies:aspecies!optional)) continue;

      if (ent.bCorpse && (flags&RGF_CORPSES)) {
        // do nothing, really
      } else {
        // check allowed flags
        if (ent.bIsPlayer) {
          // player
          if (ent.Player.PlayerState == PST_DEAD) continue;
          //if (ent.Player.bIsBot)
          if (ent.Player.MO != self) {
            // voodoo doll
            if (!(flags&RGF_VOODOO)) continue;
          } else {
            if (!(flags&RGF_PLAYERS)) continue;
          }
        } else if (ent.bMonster) {
          // monster
          if (!(flags&RGF_MONSTERS)) continue;
          if (ent.Health <= 0 && !(flags&RGF_KILLED)) continue;
        } else if (ent.bMissile) {
          // missile
          if (!(flags&RGF_MISSILES)) continue;
        } else {
          // other
          if (ent isa Inventory) {
            if (!(flags&RGF_ITEMS)) continue;
          } else {
            if (!(flags&RGF_OBJECTS)) continue;
            // should be either shootable or vulnerable
            if (!ent.bShootable && !ent.bNoDamage) continue;
          }
        }
      }

      // check NOxxx
      if (flags&(RGF_NOTARGET|RGF_NOTRACER|RGF_NOMASTER)) {
        if (flags&RGF_INCLUSIVE) {
          // should satisfy all
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : true);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : true);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : true);
          if (isTarget && isTracer && isMaster) continue;
        } else {
          bool isTarget = (flags&RGF_NOTARGET ? (Target == ent) : false);
          bool isTracer = (flags&RGF_NOTRACER ? (Tracer == ent) : false);
          bool isMaster = (flags&RGF_NOMASTER ? (Master == ent) : false);
          if (isTarget || isTracer || isMaster) continue;
        }
      }

      // sight check
      if (!(flags&RGF_NOSIGHT) && !CanSee(ent, disableBetterSight:true)) continue;
    }

    // it is ok to give an item
    if (DoGiveInventory(itemtype, amount, ent)) {
      ++count;
      if (count >= limit) break;
    }
  }

  return count;
}


//==========================================================================
//
//  decorate_CheckClass
//
//==========================================================================
[decorate] final bool decorate_CheckClass (name classname, optional int ptr_select, optional bool match_superclass) {
  Entity tgt = DecorDoAAPtr('decorate_CheckClass', ptr_select!optional);
  if (!tgt) return false;
  if (!classname) return false;
  class!Entity tc = class!Entity(tgt.Class);
  while (tc) {
    if (nameicmp(GetClassName(tc), classname) == 0) return true;
    if (!match_superclass) break;
    tc = class!Entity(GetClassParent(tc));
  }
  return false;
}


//==========================================================================
//
//  A_JumpIfRadiusAmountGreater
//
//  don't include self
//
//==========================================================================
[decorate] final void A_JumpIfRadiusAmountGreater (float aradius, int amount, class!Actor checkClass, state label, optional bool exact) {
  KeepChainResult();

  if (aradius < 0) return;
  if (!checkClass) return;
  if (amount < 1) { DoJump(label); return; }

  Entity e;
  if (exact) {
    foreach RadiusThings(e, Origin, aradius) {
      if (e.Class == checkClass) {
        if (e != self) {
          if (!(--amount)) { DoJump(label); return; }
        }
      }
    }
  } else {
    //print("=============");
    foreach RadiusThings(e, Origin, aradius) {
      //print("   %C", e);
      if (e isa checkClass) {
        if (e != self) {
          if (!(--amount)) {
            //print("%C: aradius %s; check %C; hit it!", self, aradius, checkClass);
            DoJump(label);
            return;
          }
        }
      }
    }
  }
  //print("%C: check %C with raduis %s, at %s, %s left", self, checkClass, aradius, Origin, amount);
}


//==========================================================================
//
//  A_SpawnParticle
//
//==========================================================================
[decorate] final void A_SpawnParticle (int color1, optional int flags, optional int lifetime,
                            optional float size, optional float angle,
                            optional float xoff, optional float yoff, optional float zoff,
                            optional float velx, optional float vely, optional float velz,
                            optional float accelx, optional float accely, optional float accelz,
                            optional int startalpha, optional int fadestep, optional float sizestep)
{
/*
  if (!specified_lifetime) lifetime = 35;
  if (lifetime <= 0) return;
  if (!specified_startalpha) startalpha = 255;
  if (startalpha <= 0) return;
  int clr = ParseColor(color1);
  startalpha = clamp(startalpha, 0, 255);
  clr |= startalpha<<24;
  Level.ParticleEffect(
    count:1,
    type1:pt_fading,
    type2:0,
    origin:vector(Origin.x+xoff, Origin.y+yoff, Origin.z+zoff),
    orng:0,
    velocity:vector(velx, vely, velz),
    vrnd:0,
    acceleration:0,
    grav:0,
    color:clr,
    duration:lifetime/35.0,
    ramp:clamp(fadestep, -1, 255),
    accelV:vector(accelx, accely, accelz)
  );
*/
}


//==========================================================================
//
//  A_JumpIfHigherOrLower
//
//==========================================================================
[decorate] final void A_JumpIfHigherOrLower (state high, state low, optional float offsethigh,
                                             optional float offsetlow, optional bool includeHeight,
                                             optional int aptr)
{
  KeepChainResult();
  if (!high || !low) return;
  if (!specified_aptr) aptr = AAPTR_TARGET; // per wiki
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_JumpIfHigherOrLower', aptr));
  if (!tgt || tgt == self) return; // per wiki

  if (!specified_includeHeight) includeHeight = true; // per wiki

  if (high && tgt.Origin.z > (includeHeight ? Height : 0)+Origin.z+offsethigh) {
    DoJump(high);
    return;
  }

  if (low && tgt.Origin.z+(includeHeight ? tgt.Height : 0) < Origin.z+offsetlow) {
    DoJump(low);
    return;
  }
}


//==========================================================================
//
//  A_FaceMovementDirection
//
//==========================================================================
[decorate] final bool A_FaceMovementDirection (optional float offset, optional float anglelimit,
                                               optional float pitchlimit, optional int flags,
                                               optional int aptr)
{
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_FaceMovementDirection', aptr!optional));

  if (!tgt || ((flags&FMDF_NOPITCH) && (flags&FMDF_NOANGLE))) { KeepChainResult(); return false; } //???

  // don't bother calculating this if we don't have any horizontal movement
  if (!(flags&FMDF_NOANGLE) && (tgt.Velocity.x || tgt.Velocity.y)) {
    float current = tgt.Angles.yaw;
    float angle = VectorAngleYaw(tgt.Velocity);
    // done because using anglelimit directly causes a signed/unsigned mismatch

    if (anglelimit > 0) {
      float delta = -AngleMod180(angle-current);
      if (fabs(delta) > anglelimit) {
             if (delta < 0) current += anglelimit + offset;
        else if (delta > 0) current -= anglelimit + offset;
        tgt.Angles.yaw = current; //, !!(flags & FMDF_INTERPOLATE));
      } else {
        tgt.Angles.yaw = angle+offset; //, !!(flags & FMDF_INTERPOLATE));
      }
    } else {
      tgt.Angles.yaw = angle+offset; //, !!(flags & FMDF_INTERPOLATE));
    }
  }

  if (!(flags&FMDF_NOPITCH)) {
    float current = tgt.Angles.pitch;
    //auto vel = tgt.Velocity.xy;
    float pitch = -atan2(tgt.Velocity.z, tgt.Velocity.Length2D);
    if (pitchlimit > 0) {
      float pdelta = AngleMod180(pitch-current);
      if (fabs(pdelta) > pitchlimit) {
        if (pdelta > 0) current -= fmin(pitchlimit, pdelta);
        else current += fmin(pitchlimit, -pdelta);
        tgt.Angles.pitch = current; //, !!(flags & FMDF_INTERPOLATE));
      } else {
        tgt.Angles.pitch = pitch; //, !!(flags & FMDF_INTERPOLATE));
      }
    } else {
      tgt.Angles.pitch = pitch; //, !!(flags & FMDF_INTERPOLATE));
    }
  }

  return true;
}


//==========================================================================
//
//  A_Warp
//
//==========================================================================
[decorate] final bool A_Warp (int aptr, optional float xofs, optional float yofs, optional float zofs,
                              optional float angle, optional int flags, optional state success_state,
                              optional float heightoffset, optional float radiusoffset, optional float pitch)
{
  EntityEx tgt;
  if (flags&WARPF_USETID) {
    tgt = (aptr ? EntityEx(Level.FindMobjFromTID(aptr, none)) : EntityEx(self));
  } else {
    tgt = EntityEx(DecorDoAAPtr('A_Warp', aptr));
  }

  if (!tgt) {
    KeepChainResult(); // it should not succeed
    return false;
  }

  EntityEx tomove = self;

  if (flags&WARPF_MOVEPTR) {
    tomove = tgt;
    tgt = self;
  }

  //printdebug("A_Warp: tomove=%C; tgt=%C", tomove, tgt);

  if (!(flags&WARPF_ABSOLUTEANGLE)) {
    angle += (flags&WARPF_USECALLERANGLE ? tomove.Angles.yaw : tgt.Angles.yaw);
  }
  angle = AngleMod360(angle);

  float rad = radiusoffset*tgt.Radius;
  float s, c;
  sincos(angle, out s, out c);

  //printdebug("A_Warp:   000: xofs=%s; yofs=%s; zofs=%s", xofs, yofs, zofs);

  zofs += tgt.Height*heightoffset;
  //printdebug("A_Warp:   001: xofs=%s; yofs=%s; zofs=%s", xofs, yofs, zofs);

  //FIXME!
  /*
  bIntrJustMoved = false;
  LastMoveOrigin = NewOrigin;
  */

  //!tomove.bIntrJustMoved = !!(flags&WARPF_INTERPOLATE); // disable movement interpolation
  //tomove.LastMoveOrigin = tomove.Origin;
  //tomove.LastMoveAngles = tomove.Angles;
  //tomove.LastMoveTime = XLevel.Time;

  TVec oldOrigin = tomove.Origin;

  tomove.UnlinkFromWorld();
  if (flags&WARPF_ABSOLUTEPOSITION) {
    tomove.Origin = vector(xofs+rad*c, yofs+rad*s, zofs);
  } else {
    if (!(flags&WARPF_ABSOLUTEOFFSET)) {
      float xofs1 = xofs;
      // in relative mode negative y values mean 'left' and positive ones mean 'right'
      // This is the inverse orientation of the absolute mode!
      xofs = xofs1*c+yofs*s;
      yofs = xofs1*s-yofs*c;
    }
    tomove.Origin = tgt.Origin+vector(xofs+rad*c, yofs+rad*s, (flags&WARPF_TOFLOOR ? 0.0 : zofs));
  }
  tomove.LinkToWorld();

  if (flags&WARPF_TOFLOOR) {
    float newz = (tomove.Sector ? GetPointZClamped(ref tomove.Sector->floor, tomove.Origin) : tomove.FloorZ)+zofs;
    tomove.Origin.z = newz+zofs;
  }

  tmtrace_t tmtrace;
  if ((flags&WARPF_NOCHECKPOSITION) || tomove.CheckRelPosition(out tmtrace, tomove.Origin, noPickups:true)) {
    if (flags&WARPF_TESTONLY) {
      tomove.SetOrigin(oldOrigin);
    } else {
      tomove.Angles.yaw = angle;
      if (flags&WARPF_COPYPITCH) tomove.Angles.pitch = tgt.Angles.pitch;
      if (pitch != 0) tomove.Angles.pitch += pitch;

      if (flags&WARPF_COPYVELOCITY) tomove.Velocity = tgt.Velocity;
      if (flags&WARPF_STOP) tomove.Velocity = vector(0, 0, 0);

      //TODO: WARPF_BOB

      tomove.TryMoveEx(out tmtrace, tomove.Origin, AllowDropOff:true);
      tomove.bIntrJustMoved = !!(flags&WARPF_INTERPOLATE); // disable movement interpolation
    }
    if (success_state) DoJump(success_state, affectStateCallResult:true); // chain result is not reset, so it will become `true`
    return true;
  } else {
    //FIXME: keep interpolation?
    tomove.SetOrigin(oldOrigin);
    KeepChainResult(); // it should not succeed
    return false;
  }
}


//==========================================================================
//
//  A_CheckLOF
//
//==========================================================================
[decorate] final state A_CheckLOF (optional state jump, optional int flags, optional float range,
                                   optional float minrange, optional float angle, optional float pitch,
                                   optional float offsetheight, optional float offsetwidth,
                                   optional int ptr_target, optional float offsetforward)
{
  KeepChainResult();
  if (specified_minrange) {
    printwarn("A_CheckLOF is not fully implemented yet!");
    return none;
  }

  if (range <= 0) return none;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = Aim(nullptr, range, Angles.yaw, noAutoaim:false, noVertAutoAim:false);
    if (!Targ || Targ != Target) return none;
  } else {
    // this is prolly called from weapon code, so target is what we have in player's crosshair
    //TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    bool noAAim = !PlayerEx(Player).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    //if (flags&JLOSF_NOAUTOAIM) noAAim = true;
    noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
    if (!Targ || !Targ.bShootable || !Targ.bMonster || Targ.Health <= 0) return none;
  }

  // just in case
  if (!Targ) return none;

  if (jump) DoJump(jump);
  return jump;

//final bool checkIfTargetInLOS (optional float Fov, optional int flags, optional float distmax, optional float distclose) {
/*
  name cvn = name(cvar);
  if (CvarExists(cvn)) {
    if (GetCvarB(cvn)) DoJump(Label);
  }
*/
#ifdef THIS_WILL_NEVER_BE_DEFINED_I_HOPE
  if (distmax == 0) distmax = 8192;
  Fov = fabs(Fov);

  // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
  if ((flags&JLOSF_PROJECTILE) && !bMissile) flags &= ~JLOSF_PROJECTILE;

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = Target;
    // according to https://zdoom.org/wiki/A_JumpIfTargetInLOS
         if (flags&JLOSF_CHECKMASTER) Targ = Master;
    else if (flags&JLOSF_CHECKTRACER) Targ = Tracer;
    else if (flags&JLOSF_PROJECTILE) Targ = (bSeekerMissile ? Tracer : none);
  } else {
    // this is prolly called from weapon code, so target is what we have in player's crosshair
    TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    //k8: emulate autoaim in any case
    /*
    bool noAAim = !PlayerEx(Player).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(Player).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    if (flags&JLOSF_NOAUTOAIM) noAAim = true;
    noAAVert = noAAim;
    */
    bool noAAim = !!(flags&JLOSF_NOAUTOAIM);
    bool noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
  }

  // moved here from `!bIsPlayer`
  if (!Targ) return false;

  // check target type flags before other, more expensive flags

  // combatant?
  if (flags&JLOSF_COMBATANTONLY) {
    if (!Targ.bIsPlayer && !Targ.bMonster) return false;
    if (Targ.bCorpse) return false; //k8: i added this too, as corpse is not a combatant
  }

  // dead?
  if ((flags&JLOSF_DEADNOJUMP) && Targ.Health <= 0) return false;

  // ally?
  if (flags&JLOSF_ALLYNOJUMP) {
    //FIXME: incomplete
    if (Targ == self || (bIsPlayer && Targ.bFriendly)) return false;
  }

  // check distance
  if (distclose > 0 && DistTo2(Targ) <= distclose) {
    // "close" in effect, fix flags and fov
    if (flags&JLOSF_CLOSENOJUMP) {
      // it doesn't matter what we'll do here, no jump will be taken
      return false;
    }
    if (flags&JLOSF_CLOSENOFOV) Fov = 0; // all-around vision
    if (flags&JLOSF_CLOSENOSIGHT) flags |= JLOSF_NOSIGHT;
  }

  // check sight
  if (!(flags&JLOSF_NOSIGHT)) {
    //k8: dunno, "better sight" should not be in effect here, i think
    if (flags&JLOSF_TARGETLOS) {
      if (!Targ.CanSee(self, disableBetterSight:true)) return false;
    } else {
      if (!CanSee(Targ, disableBetterSight:true)) return false;
    }
  }

  // check FOV
  if (Fov && Fov < 360.0) {
    if (flags&JLOSF_FLIPFOV) {
      // target fov
      float Ang = AngleMod180(atan2(Origin.y-Targ.Origin.y, Origin.x-Targ.Origin.x)-Targ.Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    } else {
      // our fov
      float Ang = AngleMod180(atan2(Targ.Origin.y-Origin.y, Targ.Origin.x-Origin.x)-Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    }
  }

  // all checks passed
  return true;
#endif
}


//===========================================================================
//
//  A_ResetHealth
//
//===========================================================================
[decorate] final void A_ResetHealth (optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_ResetHealth', aptr!optional));
  if (!tgt || tgt.Health <= 0) return;

  if (tgt.bIsPlayer) {
    int h = PlayerEx(tgt.Player).GetMaxHealth();
    tgt.Player.Health = h;
    tgt.Health = h;
  } else {
    tgt.Health = tgt.InitialHealth;
  }
}


//===========================================================================
//
//  A_SetDamageType
//
//===========================================================================
[decorate] final void A_SetDamageType (name atype) {
  DamageType = atype;
}


//===========================================================================
//
//  A_CopyFriendliness
//
//===========================================================================
[decorate] final void A_CopyFriendliness (optional int aptrfrom) {
  if (!specified_aptrfrom) aptrfrom = AAPTR_MASTER;
  EntityEx src = EntityEx(DecorDoAAPtr('A_CopyFriendliness', aptrfrom));
  if (!src || src == self) return;
  CopyFriendliness(src, ChangeTarget:true);
}


//==========================================================================
//
//  A_SetSpecies
//
//==========================================================================
[decorate] final void A_SetSpecies (string spname, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_SetSpecies', aptr!optional));
  if (!tgt) return;
  tgt.Species = spname;
}


//==========================================================================
//
//  A_k8MoveBy
//
//==========================================================================
[decorate] final void A_k8MoveBy (optional float dx, optional float dy, optional float dz) {
  if (!dx.isfinite || !dy.isfinite || !dz.isfinite) return;
  // so link the thing into its new position
  if (dx || dy) UnlinkFromWorld();
  Origin.x += dx;
  Origin.y += dy;
  Origin.z += dz;
  if (dx || dy) LinkToWorld(properFloorCheck:true);
  bIntrJustMoved = false; // disable movement interpolation
}


//==========================================================================
//
//  A_k8MoveTo
//
//==========================================================================
[decorate] final void A_k8MoveTo (optional float nx, optional float ny, optional float nz) {
  if (!nx.isfinite || !ny.isfinite || !nz.isfinite) return;
  // so link the thing into its new position
  if (specified_nx || specified_ny) UnlinkFromWorld();
  if (specified_nx) Origin.x = nx;
  if (specified_ny) Origin.y = ny;
  if (specified_nz) Origin.z = nz;
  if (specified_nx || specified_ny) LinkToWorld(properFloorCheck:true);
  bIntrJustMoved = false; // disable movement interpolation
}


//==========================================================================
//
//  common_k8JumpIfLiquidFloor
//
//==========================================================================
final bool common_k8JumpIfLiquidFloor (EntityEx tgt, state label) {
  KeepChainResult();
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (IsAnimatedTexture(tgt.Sector.floor.pic)) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  auto tname = string(GetTextureName(tgt.Sector.floor.pic));
  if (globmatch(tname, "*water*", caseSensitive:false) ||
      globmatch(tname, "*nukage*", caseSensitive:false) ||
      globmatch(tname, "*lava*", caseSensitive:false) ||
      globmatch(tname, "*blood*", caseSensitive:false) ||
      globmatch(tname, "*slime0*", caseSensitive:false) ||
      globmatch(tname, "*slimage*", caseSensitive:false) ||
      globmatch(tname, "f_watr*", caseSensitive:false)) // Strife water
  {
    DoJump(label);
    return true;
  }
  // slime13 and further are normal floors, not liquids
  if (tname == "slime10" || tname == "slime11" || tname == "slime12") {
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfLiquidFloor
//
//==========================================================================
[decorate] final bool A_k8JumpIfLiquidFloor (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfLiquidFloor', aptr!optional));
  return common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnLiquidFloor
//
//==========================================================================
[decorate] final bool A_k8JumpIfOnLiquidFloor (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfOnLiquidFloor', aptr!optional));
  if (tgt.Origin.z > tgt.FloorZ) { KeepChainResult(); return false; }
  return common_k8JumpIfLiquidFloor(tgt, label);
}


//==========================================================================
//
//  A_k8JumpIfOnFloorSky
//
//==========================================================================
[decorate] final bool A_k8JumpIfOnFloorSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  KeepChainResult();
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Origin.z > tgt.FloorZ) return false;
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfFloorSky
//
//==========================================================================
[decorate] final bool A_k8JumpIfFloorSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  KeepChainResult();
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Sector.floor.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}


//==========================================================================
//
//  A_k8JumpIfCeilingSky
//
//==========================================================================
[decorate] final bool A_k8JumpIfCeilingSky (state label, optional int aptr) {
  EntityEx tgt = EntityEx(DecorDoAAPtr('A_k8JumpIfSkyFloor', aptr!optional));
  KeepChainResult();
  if (!tgt) return false;
  if (!tgt.Sector) return false; // just in case
  if (tgt.Sector.ceiling.pic == Level.Game.skyflatnum) {
    //print("ANIM FLOOR: %s", GetTextureName(tgt.Sector.floor.pic));
    DoJump(label);
    return true;
  }
  return false;
}
