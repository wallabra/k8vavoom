//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************

//==========================================================================
//
//  Destroyed
//
//==========================================================================
override void Destroyed () {
  if (Role == ROLE_Authority) {
    // remove inventory
    while (Inventory) Inventory.Destroy();
  }
  ::Destroyed();
}


//==========================================================================
//
//  SetOrigin2
//
//==========================================================================
final void SetOrigin2 (TVec origin) {
  UnlinkFromWorld();

  Origin = origin;

  // set subsector and/or block links
  LinkToWorld();

  //k8: why nointeraction is not processed?
  /*if (!bNoInteraction)*/ {
         if (origin.z == ONFLOORZ) Origin.z = FloorZ;
    else if (origin.z == ONCEILINGZ) Origin.z = CeilingZ-Height;
    else if (origin.z == FLOATRANDZ) {
      float space = CeilingZ-Height-FloorZ;
      if (space > 48.0) {
        space -= 40.0;
        Origin.z = space*Random()+FloorZ+40.0;
      } else {
        Origin.z = FloorZ;
      }
    } else if (bFloatBob) {
      Origin.z = FloorZ+Origin.z; // artifact z passed in as height
    }

    VTerrainInfo *TInfo = GetFloorType();
    if (bFloorClip && TInfo->bLiquid && Origin.z == FloorZ) {
      FloorClip = TInfo->FootClip;
    } else {
      FloorClip = 0.0;
    }
  }
}


//**************************************************************************
//
//  RADIUS ATTACK
//
//**************************************************************************

//==========================================================================
//
//  RadiusAttack
//
//  Source is the creature that caused the explosion at spot.
//
//==========================================================================
final void RadiusAttack (EntityEx Source, int BombDamage, float BombDistance,
                         bool DamageSource, optional name BombDmgType, optional bool DoDamage,
                         optional int damagedistance, optional bool thrustZ,
                         optional float fullthrustdistance)
{
  EntityEx Other;
  //float dist;
  //int damage;

  if (!specified_thrustZ) thrustZ = DoDamage; //k8: see below

  if (!specified_DoDamage) DoDamage = true;

  foreach RadiusThings(Other, Origin, BombDistance) {
    if (!Other || !Other.bShootable) continue;

    // check for actors that take no damage from concussion
    if (Other.bNoRadiusDamage && !bForceRadiusDmg) continue;

    if (!DamageSource && Other == Source) continue; // don't damage the source of the explosion

    // option for monsters that fire explosive projectiles not to hurt
    // monsters of the same class with it's projectiles.
    // controlled by the bDontHurtClass and bDontHurtSpecies flags.
    if (Source && !Other.bIsPlayer &&
        ((Source.bDontHurtClass && Other.Class == Source.Class) ||
         (Source.bDontHurtSpecies && Other.GetSpecies() == Source.GetSpecies())))
    {
      continue;
    }

    float dist = fmax(0.0, Length(Other.GetCentre()-GetCentre())-Other.Radius);

    if (dist >= BombDistance) continue; // out of range

    if (Other.CanSee(self)) {
      float dist2;

      // OK to damage, target is in direct path
      if (!specified_damagedistance) {
        dist2 = dist;
      } else {
        dist2 = fclamp(dist-float(damagedistance), 0.0, dist);
      }

      int damage = int(((float(BombDamage)*RDFactor*(BombDistance-dist2))/BombDistance));

      Other.SpawnExploBloodAtHead(damage, Source);
      if (DoDamage) {
        Other.Damage(self, Source, damage, BombDmgType);
      } else {
        Other.bBlasted = true;
      }

      if (!Other.bIceCorpse && (!DoDamage || !bNoDamageThrust)) {
        float Thrust = float(damage)*0.5;
        if (specified_fullthrustdistance && fullthrustdistance != 0 && dist <= fullthrustdistance) {
          Thrust = BombDamage*RDFactor*0.5;
        }
        float VelZ = ((Other.Origin.z+(Other.Height*0.5))-Origin.z)*Thrust;
        if (Source != Other) VelZ *= 0.5; else VelZ *= 0.8;
        TVec Dir = Other.Origin-Origin;
        Dir.z = 0.0;
        if (Length2D(Dir) < 0.001) {
          // zero length. In this case Doom would use angle 0
          Dir = vector(1.0, 0.0, 0.0);
        }
        float othermass = fmax(1, Other.Mass);
        TVec Vel = Normalise(Dir)*Thrust;
        Other.Velocity.x += (Vel.x/othermass)*35.0;
        Other.Velocity.y += (Vel.y/othermass)*35.0;
        if (thrustZ) Other.Velocity.z += (VelZ/othermass)*35.0;
        //old:if (DoDamage) Other.Velocity.z += (VelZ / Other.Mass) * 35.0;
      }
    }
  }
}


//==========================================================================
//
//  TeleportMove
//
//==========================================================================
final bool TeleportMove (TVec org, optional bool ForceTelestomp) {
  EntityEx Other;
  float blockdist;

  // kill anything occupying the position
  // stomp on any things contacted
  foreach RadiusThings(Other, org, Radius) {
    if (!Other.bShootable) continue;

    blockdist = Other.Radius+Radius;

    if (fabs(Other.Origin.x-org.x) >= blockdist ||
        fabs(Other.Origin.y-org.y) >= blockdist)
    {
      // didn't hit it
      continue;
    }

    // don't clip against self
    if (Other == self) continue;

    // z-check
    if ((bPassMobj || Other.bActLikeBridge) && !Level.CompatNoPassOver &&
        (!bDontOverlap || !Other.bDontOverlap))
    {
      if (Other.Origin.z > org.z+Height) continue;
      if (Other.Origin.z+Other.Height < org.z) continue;
    }

    // check if allowed to stomp things
    if ((!ForceTelestomp && !bTelestomp && !Level.bAllowMonsterTelefrags) || Other.bNoTeleFrag) {
      return false;
    }

    Other.SpawnExploBloodAtHead(max(Other.Health, 10000), self);
    // telefrags kills even invincible things
    Other.Damage(self, self, max(Other.Health, 10000), 'Telefrag', forced:true/*, spawnBlood:true*/);
  }

  // the move is ok,
  // so link the thing into its new position
  UnlinkFromWorld();
  Origin = org;
  LinkToWorld();
  if (org.z == ONFLOORZ) Origin.z = FloorZ;

  return true;
}


//==========================================================================
//
//  Teleport
//
//==========================================================================
final bool Teleport (TVec Dst, float angle, bool DstFog, bool SrcFog, bool KeepDir, optional bool ForceTelestomp) {
  float fogDelta;
  EntityEx fog;
  bool ResetPitch = false;

  TVec oldOrg = Origin;
  float aboveFloor = Origin.z-FloorZ;
  if (Dst.z == ONFLOORZ) {
    sector_t *DstSec = XLevel.PointInSector(Dst);
    float DstFloorZ = GetPlanePointZ(ref DstSec->floor, Dst);
    float DstCeilZ = GetPlanePointZ(ref DstSec->floor, Dst);
    if (bIsPlayer) {
      if (FindInventory(PowerFlight) && aboveFloor) {
        Dst.z = DstFloorZ+aboveFloor;
        if (Dst.z+Height > DstCeilZ) Dst.z = DstCeilZ-Height;
      } else {
        Dst.z = DstFloorZ;
        if (!KeepDir) ResetPitch = true;
      }
    } else if (bMissile) {
      Dst.z = Dst.z+aboveFloor;
      if (Dst.z+Height > DstCeilZ) Dst.z = DstCeilZ-Height;
    } else {
      Dst.z = DstFloorZ;
    }
  }
  if (!TeleportMove(Dst, ForceTelestomp!optional)) return false;
  if (bIsPlayer && Player.MO == self) {
    Player.ViewOrg = Origin+vector(0.0, 0.0, PlayerEx(Player).ViewHeight);
    if (ResetPitch) Angles.pitch = 0.0;
  }
  // spawn teleport fog at source and destination
  fogDelta = (bMissile ? 0.0 : LineSpecialGameInfo(Level.Game).TeleFogHeight);
  if (SrcFog) Spawn(TeleportFog, oldOrg+vector(0.0, 0.0, fogDelta));
  if (DstFog) Spawn(TeleportFog, Origin+vector(20.0*cos(angle), 20.0*sin(angle), fogDelta));
  if (!KeepDir) {
    if (bIsPlayer && !FindInventory(PowerWeaponLevel2) && !FindInventory(PowerSpeed)) {
      // don't move for a bit, freeze player for about .5 sec
      ReactionTime = 0.5;
    }
    Angles.yaw = angle;
    if (bIsPlayer) Player.bFixAngle = true;
  }
  HandleFloorclip();
  if (bMissile) {
    Velocity.x = Speed*cos(angle);
    Velocity.y = Speed*sin(angle);
  } else if (!KeepDir) {
    // no fog doesn't alter the player's momentums
    Velocity = vector(0.0, 0.0, 0.0);
  }
  return true;
}


//===========================================================================
//
//  MoveThing
//
//===========================================================================
override bool MoveThing (TVec Pos, bool Fog) {
  TVec OldOrg = Origin;

  UnlinkFromWorld();
  Origin = Pos;
  LinkToWorld();
  if (TestLocation()) {
    if (Fog) {
      Spawn(TeleportFog, Pos+vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
      Spawn(TeleportFog, OldOrg+vector(0.0, 0.0, LineSpecialGameInfo(Level.Game).TeleFogHeight));
    }
    return true;
  } else {
    UnlinkFromWorld();
    Origin = OldOrg;
    LinkToWorld();
    return false;
  }
}


//==========================================================================
//
//  TestLocation
//
//  Returns true if the mobj is not blocked by anything at its current
//  location, otherwise returns false.
//
//==========================================================================
final bool TestLocation () {
  if (!bColideWithThings && !bColideWithWorld) return true;
  if (CheckPosition(Origin)) {
    // XY is ok, now check Z
    if ((Origin.z < FloorZ) || (Origin.z+Height > CeilingZ)) {
      // bad Z
      return false;
    }
    return true;
  }
  return false;
}


//==========================================================================
//
//  Thrust
//
//==========================================================================
final void Thrust (float angle, float move) {
  Velocity.x += move*cos(angle)*35.0;
  Velocity.y += move*sin(angle)*35.0;
}


//==========================================================================
//
//  FaceActor
//
//  Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//==========================================================================
int FaceActor (EntityEx target, out float delta) {
  float angle1 = Angles.yaw;
  float angle2 = atan2(target.Origin.y-Origin.y, target.Origin.x-Origin.x);
  if (angle2 > angle1) {
    float diff = AngleMod360(angle2-angle1);
    if (diff > 180.0) {
      delta = 360.0-diff;
      return 0;
    } else {
      delta = diff;
      return 1;
    }
  } else {
    float diff = AngleMod360(angle1-angle2);
    if (diff > 180.0) {
      delta = 360.0-diff;
      return 1;
    } else {
      delta = diff;
      return 0;
    }
  }
}


//==========================================================================
//
//  HeightClip
//  called from `SectorChanged()`
//
//  Takes a valid thing and adjusts the thing->FloorZ, thing->CeilingZ, and
//  possibly thing->z. This is called for all nearby monsters whenever a
//  sector changes height. If the thing doesn't fit, the z will be set to
//  the lowest value and false will be returned.
//
//==========================================================================
final bool HeightClip () {
  tmtrace_t tmtrace;
  float OldZ = Origin.z;
  bool onfloor = (Origin.z == FloorZ);

  // "no interaction" and "no blockmap" just moving
  if (bNoInteraction || bNoBlockmap) {
    //k8: always move?
    if (bMoveWithSector && !bNoSector) {
      // faster checking
      GetFloorAndCeiling(out tmtrace);
      // update position
      Floor = tmtrace.Floor;
      Ceiling = tmtrace.Ceiling;
      FloorZ = tmtrace.FloorZ;
      CeilingZ = tmtrace.CeilingZ;
      if (bStickToFloor || bStickToCeiling) {
        Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
      } else {
        if (onfloor) {
          if (bNoInteraction || !bNoGravity || Origin.z < FloorZ) {
            Origin.z = FloorZ;
          }
        } else {
          // don't adjust a floating thing unless forced to
          if (Origin.z+Height > CeilingZ) Origin.z = CeilingZ-Height;
        }
      }
    } else if (bStickToFloor || bStickToCeiling) {
      GetFloorAndCeiling(out tmtrace);
      Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
    }
    // never blocks
    return true;
  }

  CheckRelPosition(&tmtrace, Origin);
  // what about stranding a monster partially off an edge?

  Floor = tmtrace.Floor;
  Ceiling = tmtrace.Ceiling;
  FloorZ = tmtrace.FloorZ;
  CeilingZ = tmtrace.CeilingZ;

  if (onfloor && (!bNoGravity || !bNoLiftDrop || bMoveWithSector)) {
    // walking monsters rise and fall with the floor
    if ((Origin.z-FloorZ < 9.0) || bNoGravity || !XLevel.bExtended) {
      EntityEx onmo = EntityEx(CheckOnmobj());
      // do we have something over us?
      if (bSolid && onmo && onmo.bSolid) {
        // adjust height for the thing over us
        onmo.Origin.z += FloorZ-Origin.z;
        // don't adjust a floating monster unless forced to
        if (onmo.Origin.z+onmo.Height > CeilingZ) {
          onmo.Origin.z = CeilingZ-onmo.Height;
        }
        if (CeilingZ-(FloorZ+Height) < onmo.Height) {
          // things don't fit, stop
          return false;
        }
      }
      Origin.z = FloorZ;
    }
  } else {
    // don't adjust a floating monster unless forced to
    if (Origin.z+Height > CeilingZ) {
      Origin.z = CeilingZ-Height;
    }
  }

  CheckFakeFloorTriggers(OldZ);

  if (CeilingZ-FloorZ < Height) {
    if (bIceCorpse && bSolid) {
      Actor(self).A_FreezeDeathChunks();
      return true;
    } else {
      // doesn't fit, stop
      return false;
    }
  }

  if (bStickToFloor || bStickToCeiling) {
    Origin.z = (bStickToFloor ? tmtrace.FloorZ : tmtrace.CeilingZ-Height);
  }

  return true;
}


//==========================================================================
//
//  GetStateTime
//
//==========================================================================
override float GetStateTime (state AState, float AStateTime) {
  if (AState) {
    switch (GetStateTicKind(AState)) {
      //case StateTicKind.Normal: return AStateTime;
      case StateTicKind.Random: AStateTime = float(GetStateArgN(AState, 0)+trunc(Random()*(GetStateArgN(AState, 1)-GetStateArgN(AState, 0)+1)))/35.0f; break;
      //default: return AStateTime;
    }
    if (IsFast()) {
           if (bFaster && StateIsInRange(AState, SeeState, none, 8)) AStateTime /= 2.0;
      else if (bFastMelee && StateIsInRange(AState, MeleeState, none, 3)) AStateTime /= 2.0;
      else {
        auto fff = GetStateSpriteFrame(AState);
        if (fff&FF_FAST) AStateTime /= 2.0;
      }
    } else if (Level.Game.fastparm == 2) {
      // slow monsters
      auto fff = GetStateSpriteFrame(AState);
      if (fff&FF_SLOW) AStateTime *= 2.0;
    }
  }
  return AStateTime;
}


//==========================================================================
//
//  NightmareRespawn
//
//==========================================================================
final void NightmareRespawn () {
  float z;

  ++SkillRespawnCount;

  float x = SpawnPoint.x;
  float y = SpawnPoint.y;

  // somthing is occupying it's position?
  if (!CheckPosition(vector(x, y, ONFLOORZ))) return; // no respwan

  // spawn a teleport fog at old spot
  EntityEx A = Spawn(TeleportFog, vector(Origin.x, Origin.y, ONFLOORZ));
  A.Origin.z += LineSpecialGameInfo(Level.Game).TeleFogHeight;

  // spawn a teleport fog at the new spot
  A = Spawn(TeleportFog, vector(x, y, ONFLOORZ));
  A.Origin.z += LineSpecialGameInfo(Level.Game).TeleFogHeight;

  // spawn the new monster

  // spawn it
  if (bSpawnCeiling) z = ONCEILINGZ; else z = ONFLOORZ;

  // inherit attributes from deceased one
  A = Spawn(class!EntityEx(Class), vector(x, y, z), default, default, false);
  Level.CopyMThing(&SpawnPoint, &A.SpawnPoint);
  A.Angles.yaw = float(45*(SpawnPoint.angle/45));

  if (SpawnPoint.options&LineSpecialLevelInfo::MTF_AMBUSH) A.bAmbush = true;
  if (SpawnPoint.options&LineSpecialLevelInfo::MTF_STANDSTILL) A.bStanding = true;

  A.ReactionCount = 18;

  // copy custom translation
  A.Translation = Translation;

  A.SkillRespawnCount = SkillRespawnCount;

  // remove the old monster
  Destroy();
}


//==========================================================================
//
//  ProcessHitFlags
//
//  returns `false` if hit something
//
//==========================================================================
final bool ProcessHitFlags (EntityEx Other, bool res) {
  if (res) return res; // `true` means "continue, no hit"
  if (!Other || Other == self || !bMissile) return res; //k8: only for missiles?
  if (bHitTarget) Target = Other;
  if (bHitMaster) Master = Other;
  if (bHitTracer) Tracer = Other;
  return res;
}


//==========================================================================
//
//  Touch
//
//  returns `false` if hit something
//
//==========================================================================
override bool Touch (Entity InOther) {
  bool solid;
  int damage;
  EntityEx Other = EntityEx(InOther);

  // for Korax Arena
  if (Other.IsTouched(self)) {
    return ProcessHitFlags(Other, !Other.bSolid && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors);
  }

  //k8: missile should hit shootable object even if it is non-solid
  if (bMissile) {
    if (!(Other.bSolid || Other.bShootable) && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors) return ProcessHitFlags(Other, true);
  } else {
    if (!Other.bSolid && !Other.bSpecial && (!Other.bShootable || !Other.bTouchy) && !Other.bBlockedBySolidActors) return ProcessHitFlags(Other, true);
  }

  if (bThruActors || Other.bThruActors) return ProcessHitFlags(Other, true);

  if (bThruSpecies && (Other.GetSpecies() == GetSpecies())) return ProcessHitFlags(Other, true);

  // touchy object is alive, toucher is solid
  if (Other.bTouchy && bSolid && Other.Health > 0 &&
      // thing is an armed mine or a sentient thing
      (Other.bArmed || Other.IsSentient()) &&
      // either different classes or players
      (Other.bIsPlayer || Other.Class != Class) &&
      // or different species if DONTHARMSPECIES
      (!(Other.bDontHurtSpecies) || Other.GetSpecies() != GetSpecies()) &&
      // touches vertically
      Other.Origin.z+Other.Height >= Origin.z && Origin.z+Height >= Other.Origin.z &&
      // prevents lost souls from exploding when fired by pain elementals
      (Other.Master != self && Master != Other))
  // difference with MBF: MBF hardcodes the LS/PE check and lets actors of the same species
  // but different classes trigger the touchiness, but that seems less straightforwards
  {
    bArmed = false; // Disarm
    Other.SpawnExploBloodAtHead(Other.Health, self);
    Other.Damage(none, none, Other.Health); // kill object
    return ProcessHitFlags(Other, true);
  }

  // Check for bBumpSpecial
  // By default, only players can activate things by bumping into them
/*  if (bBumpSpecial && (Other.bIsPlayer
    || ((thing->activationtype & THINGSPEC_MonsterTrigger) && (tm.thing->flags3 & MF3_ISMONSTER))
    || ((thing->activationtype & THINGSPEC_MissileTrigger) && (tm.thing->flags & MF_MISSILE))
    ) && (level.maptime > LastBump)) // Leave the bumper enough time to go away
  {
    if (P_ActivateThingSpecial(thing, tm.thing))
    {
      LastBump = level.maptime + TICRATE;
    }
  }*/

  // check for skulls slamming into things
  if (bSkullFly) return ProcessHitFlags(Other, Slam(Other));

  // check for blasted thing running into another
  if (bBlasted && Other.bShootable) {
    if (!Other.bBoss && Other.bMonster) {
      Other.Velocity.x += Velocity.x;
      Other.Velocity.y += Velocity.y;
      if ((Other.Velocity.x+Other.Velocity.y) > 3.0*35.0) {
        damage = (int(fmax(0, Mass))/100)+1;
        Other.SpawnExploBloodAtHead(damage, self);
        Other.Damage(self, self, damage);
        damage = (int(fmax(0, Other.Mass))/100)+1;
        SpawnExploBloodAtHead(damage>>2, Other);
        Damage(Other, Other, damage>>2);
      }
      return ProcessHitFlags(Other, false);
    }
  }

  // missiles can hit other things
  if (bMissile) {
    // check for a non-shootable mobj
    if (Other.bNonShootable) return ProcessHitFlags(Other, true);
    // check for passing through a ghost
    if (Other.bGhost && bThruGhost) return ProcessHitFlags(Other, true);

    if (bMThruSpecies && Target && (Target.GetSpecies() == GetSpecies())) return ProcessHitFlags(Other, true);

    if ((BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen) && MissileDamage == 0) {
      return ProcessHitFlags(Other, (Target == Other || !Other.bSolid));
    }

    switch (SpecialMissileHit(Other)) {
      case 0: return ProcessHitFlags(Other, false);
      case 1: return ProcessHitFlags(Other, true);
    }

    if (Target) {
      // don't hit same species as originator
      if (!bHitOwner && Other == Target) return ProcessHitFlags(Other, true); // don't missile self
      // let players missile other players
      if (!Target.bIsPlayer && !Other.bIsPlayer) {
        int Inf = Target.GetInfighting();
        if (Inf < 0) {
          // monsters can't hurt each other, but make exception
          // depending on friendliness and hate status
          if (Target.bShootable) {
            if (!Other.bMonster) return ProcessHitFlags(Other, false);
            // hostile monsters can always hurt each other
            if (!Other.IsHostile(Target)) {
              // the same if the shooter hates the target
              if (!Other.TID || Target.TIDToHate != Other.TID) return ProcessHitFlags(Other, false);
            }
          }
        } else if (Inf == 0) {
          //print("TOUCH: self=%n; other=%n; inf=%d", GetClassName(Class), GetClassName(Other.Class), Inf);
          if (Other.IsFriend(Target)) return ProcessHitFlags(Other, false); // don't hurt friends
          //print("  not friends");
          if (Other.TIDToHate && Other.TIDToHate == Target.TIDToHate) {
            // don't hurt monsters that hate the same thing as you do
            return ProcessHitFlags(Other, false);
          }
          //print("  hates");
          //print("  species: target is '%n', other is '%n'", Target.GetSpecies(), Other.GetSpecies());
          //print("  species: target is '%s', other is '%s'", string(Target.GetSpecies()), string(Other.GetSpecies()));
          if (Target.GetSpecies() == Other.GetSpecies()) {
            // don't hurt same species, but only if the target isn't one's hostile
            if (!Other.IsHostile(Target)) {
              // allow hurting monsters the shooter hates
              if (Other.TID == 0 || Target.TIDToHate != Other.TID) return ProcessHitFlags(Other, false);
            }
          }
          //print("  different species");
        }
      }
    }

    if (!Other.bShootable) return ProcessHitFlags(Other, !Other.bSolid); // didn't do any damage

    // don't hit spectres with non-sigil weapons
    if (Other.bSpectral && !bSpectral) return ProcessHitFlags(Other, true);

    if (bRip && !Other.bDontRip) {
      if (!bNoBossRip || !Other.bBoss) {
        if (!Other.bNoBlood && !Other.bReflective && !Other.bInvulnerable) {
          // ok to spawn some blood
          SpawnRipperBlood();
        }
        PlaySound('misc/ripslop', /*CHAN_BODY*/CHAN_AUTO);
        damage = GetMissileDamage(3, 2);
        Other.SpawnExploBloodAtHead(damage, self);
        Other.Damage(self, Target, damage, DamageType);
        if (Other.bPushable && !bCannotPush) {
          // push thing
          Other.Velocity.x += Velocity.x/4.0;
          Other.Velocity.y += Velocity.y/4.0;
        }
      }
      return ProcessHitFlags(Other, true);
    }

    // damage / explode
    damage = GetMissileDamage(bStrifeDamage ? 3 : 7, 1);
    if (damage > 0) {
      if (bBloodSplatter && !Other.bNoBlood && !Other.bReflective &&
          !Other.bInvulnerable && !Other.bDormant &&
          !bBloodlessImpact && P_Random() < 192)
      {
        TVec org = self.Origin;
        if (self.Radius > 0) org.z += self.Radius/2.0;
        Other.SpawnBloodSplatter(Origin, damage, org);
      }
      Other.SpawnExploBloodAtHead(damage, self);
      Other.Damage(self, Target, damage, DamageType);
    }
    // don't traverse any more
    return ProcessHitFlags(Other, false);
  }

  if (Other.bPushable && !bCannotPush) {
    // push thing
    Other.Velocity.x += Velocity.x/4.0;
    Other.Velocity.y += Velocity.y/4.0;
  }

  solid = (Other.bSolid && Other.bColideWithThings && bSolid);

  // check for special pickup
  if (Other.bSpecial /*&& Other.Origin.z < Origin.z+Height-MaxStepHeight*/) {
    if (Other.bDehackedSpecial) {
      Other.TouchDehackedSpecial(self);
    } else {
      Other.TouchSpecial(self); // can remove thing
    }
    if (solid && (!Other || Other.IsDestroyed())) solid = false; // k8: it is no more
  }

  return ProcessHitFlags(Other, !solid);
}


//==========================================================================
//
//  IsTouched
//
//  For Korax Arena
//
//==========================================================================
bool IsTouched (Entity Toucher) {
  return false;
}


//===========================================================================
//
//  Slam
//
//===========================================================================
bool Slam (EntityEx Other) {
  bSkullFly = false;
  Velocity = vector(0.0, 0.0, 0.0);
  if (Health > 0) {
    if (!bDormant) {
      int damage = GetMissileDamage(7, 1);
      if (damage > 0) Other.SpawnBloodAtHead(damage, Origin);
      Other.Damage(self, self, damage, 'Melee');
      SetState(SeeState ? SeeState : IdleState);
    } else {
      SetState(IdleState);
      StateTime = -1.0;
    }
  }
  return false; // stop moving
}


//==========================================================================
//
//  GetMissileDamage
//
//==========================================================================
int GetMissileDamage (int Mask, int Add) {
  if (!MissileDamage) return 0;
  if (!Mask) return Add*MissileDamage;
  return ((P_Random()&Mask)+Add)*MissileDamage;
}


//==========================================================================
//
//  SpecialMissileHit
//
//==========================================================================
int SpecialMissileHit (EntityEx Other) {
  return -1;
}


//==========================================================================
//
//  GetSpecies
//
//==========================================================================
name GetSpecies () {
  if (Species) return name(Species);

  class Ret = Class;
  //  Go up in the inheritance hierarchy while there's a monster flag
  // and use the top one as species.
  if (bMonster) {
    while (class!EntityEx(GetClassParent(Ret)) &&
           class!EntityEx(GetClassParent(Ret)).default.bMonster)
    {
      Ret = GetClassParent(Ret);
    }
  }
  return GetClassName(Ret);
}


//===========================================================================
//
//  CheckForPushSpecial
//
//===========================================================================
override void CheckForPushSpecial (line_t *line, int side) {
  if (!bNoTrigger) {
    if (bActivatePushWall) {
      LineSpecialLevelInfo(Level).ActivateLine(line, self, side, SPAC_Push);
    } else if (bActivateImpact) {
      LineSpecialLevelInfo(Level).ActivateLine(line,
        Level.bMissilesActivateImpact || !bMissile || !Target ? self : Target, side, SPAC_Impact);
    }
  }
}


//==========================================================================
//
//  BlastedHitLine
//
//==========================================================================
override void BlastedHitLine () {
  int damage = int(fmax(0, Mass))>>5;
  if (damage > 0) SpawnExploBloodAtHead(damage);
  Damage(none, none, damage);
}


//==========================================================================
//
//  CrossSpecialLine
//
//==========================================================================
override void CrossSpecialLine (line_t *ld, int side) {
  if (!ld) return; //k8: just in case
  if (!bNoTrigger) {
    if (bIsPlayer) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_Cross);
    } else if (bActivateMCross) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCross);
    } else if (bActivatePCross) {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_PCross);
    } else if (ld->special == LNSPEC_Teleport ||
               ld->special == LNSPEC_TeleportNoFog ||
               ld->special == LNSPEC_TeleportLine)
    {
      // teleport hack
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_MCross);
    } else {
      LineSpecialLevelInfo(Level).ActivateLine(ld, self, side, SPAC_AnyCross);
    }
  }
}


//==========================================================================
//
//  Activate
//
//==========================================================================
bool Activate (EntityEx Activator) {
  //print("*** ACTIVATING THING %C (tid=%s); bMonster=%B; bDormant=%B; Target=%C; Master=%C; Tracer=%C", self, TID, bMonster, bDormant, Target, Master, Tracer);
  if (bMonster) {
    // Monster
    if (bDormant) {
      bDormant = false;
      StateTime = 0.1;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  Deactivate
//
//==========================================================================
bool Deactivate (EntityEx Activator) {
  if (bMonster) {
    // Monster
    if (!bDormant) {
      bDormant = true;
      state S = FindState('Inactive');
      if (S) {
        SetState(S);
      } else {
        StateTime = -1.0;
      }
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  FaceMovementDirection
//
//==========================================================================
final void FaceMovementDirection () {
  switch (MoveDir) {
    case DI_EAST: Angles.yaw = 0.0; break;
    case DI_NORTHEAST: Angles.yaw = 45.0; break;
    case DI_NORTH: Angles.yaw = 90.0; break;
    case DI_NORTHWEST: Angles.yaw = 135.0; break;
    case DI_WEST: Angles.yaw = 180.0; break;
    case DI_SOUTHWEST: Angles.yaw = 225.0; break;
    case DI_SOUTH: Angles.yaw = 270.0; break;
    case DI_SOUTHEAST: Angles.yaw = 315.0; break;
  }
}


//==========================================================================
//
//  OnMapSpawn
//
//==========================================================================
override void OnMapSpawn (mthing_t *mthing) {
  ::OnMapSpawn(mthing);

  if (IsFast()) ReactionCount = 0;

  LastLook = P_Random()%MAXPLAYERS;

  bCheckLineBlocking = false;
  bCheckLineBlockMonsters = false;
  if (!bNoInteraction && !bMissile) {
    bCheckLineBlocking = true;
    if (!bNoBlockMonst) bCheckLineBlockMonsters = true;
  }

  if (!IdleState) IdleState = FindState('Spawn');
  if (!SeeState) SeeState = FindState('See');
  if (!MeleeState) MeleeState = FindState('Melee');
  if (!MissileState) MissileState = FindState('Missile');

  if (Level.Game.fastparm == 1 && FastSpeed) Speed = FastSpeed;

  if (CountsAsKill()) ++Level.TotalKills;
  if (bCountItem) ++Level.TotalItems;

  // set the state, but do not use SetState, because action routines can't be called yet
  // if the spawnstate has an action routine, it will not be called
  SetInitialState(IdleState);

  if (mthing) {
    if (bNoDeathmatch && Level.Game.deathmatch) {
      Destroy();
      return;
    }

    Level.CopyMThing(mthing, &SpawnPoint);

    float x = mthing->x;
    float y = mthing->y;
    float z;
         if (bSpawnCeiling) z = ONCEILINGZ;
    else if (bSpawnFloat) z = FLOATRANDZ;
    else if (bFloatBob) z = mthing->height;
    else z = ONFLOORZ;

    SetOrigin2(vector(x, y, z));
         if (z == ONFLOORZ) Origin.z += mthing->height;
    else if (z == ONCEILINGZ) Origin.z -= mthing->height;

    //if (mthing.type == 43 || mthing.type == 54) print("TREE (%d) spawned at %v <%f,%f>", mthing.type, Origin, mthing.x, mthing.y);
    //if (mthing.type == 43 || mthing.type == 54) print("TREE (%d) spawned at %v <%f,%f>, height=%f", mthing.type, Origin, mthing.x, mthing.y, Height);

    LinkToWorld();

    SetTID(mthing->tid);
    Special = mthing->special;
    if (!bArgsDefined) {
      Args[0] = mthing->arg1;
      Args[1] = mthing->arg2;
      Args[2] = mthing->arg3;
      Args[3] = mthing->arg4;
      Args[4] = mthing->arg5;
    }
    if (bFloatBob) {
      // seed random starting index for bobbing motion
      FloatBobPhase = Random()*256.0/35.0;
      Special1f = mthing->height;
    }
    if (!bSynchronised && StateTime > 0.0) StateTime = 0.1+Random()*StateTime;

    Angles.yaw = float(AngleIncrements()*(mthing->angle/AngleIncrements()));
    if (mthing->options&LineSpecialLevelInfo::MTF_AMBUSH) bAmbush = true;
    if (mthing->options&LineSpecialLevelInfo::MTF_STANDSTILL) bStanding = true;
    if (mthing->options&LineSpecialLevelInfo::MTF_DORMANT) Deactivate(none);
    if (mthing->options&LineSpecialLevelInfo::MTF_FRIENDLY) {
      bFriendly = true;
      // friendlies don't count as kills
      if (bCountKill) {
        bCountKill = false;
        --Level.TotalKills;
      }
    }
    if (mthing->options&LineSpecialLevelInfo::MTF_SHADOW) {
      bShadow = true;
      RenderStyle = STYLE_Translucent;
      Alpha = 0.25;
    } else if (mthing->options&LineSpecialLevelInfo::MTF_ALTSHADOW) {
      RenderStyle = STYLE_None;
    }
  } else {
         if (bSpawnCeiling) Origin.z = ONCEILINGZ;
    else if (bSpawnFloat) Origin.z = FLOATRANDZ;
    //else if (bFloatBob) Origin.z = mthing->height;
    //else z = ONFLOORZ;
    SetOrigin2(Origin);
  }

  if (bStaticLight && mthing && !TID) {
    if (LightColour == 0xffffffff) {
      Level.AddStaticLight(Origin+LightOffset, mthing->arg1 ? float(mthing->arg1)*8.0 : LightRadius);
    } else {
      Level.AddStaticLightRGB(Origin+LightOffset, mthing->arg1 ? float(mthing->arg1)*8.0 : LightRadius, LightColour);
    }
    bStaticLightSpawned = true;
  }

  //print("SPAWNED: %C (%B)", self, bSolid);
}


//==========================================================================
//
//  CanSeek
//
//  Checks if a seeker missile can home in on its target
//
//==========================================================================
bool CanSeek (EntityEx Targ) {
  if (Targ.bCantSeek) return false;
  if (bDontSeekInvisible && (Targ.bShadow || Targ.bGhost)) return false;
  return true;
}


//==========================================================================
//
//  SeekerMissile
//
//  the missile Tracer field must be Actor target
//  returns true if target was tracked, false if not
//
//==========================================================================
final bool SeekerMissile (float thresh, float turnMax, optional bool precise, optional bool curspeed) {
  float dist;
  float delta;

  if (!Tracer) return false;
  if (!Tracer.bShootable) {
    // target died
    Tracer = none;
    return false;
  }

  int dir = FaceActor(Tracer, delta);
  if (delta > thresh) {
    delta /= 2.0;
    if (delta > turnMax) delta = turnMax;
  }
  if (dir) {
    // turn clockwise
    Angles.yaw = AngleMod360(Angles.yaw+delta);
  } else {
    // turn counter clockwise
    Angles.yaw = AngleMod360(Angles.yaw-delta);
  }

  float angle = Angles.yaw;

  //k8: is this right?
  if (!curspeed) {
    if (!precise) {
      Velocity.x = Speed*cos(angle);
      Velocity.y = Speed*sin(angle);
      if (Origin.z+Height < Tracer.Origin.z ||
          Tracer.Origin.z+Tracer.Height < Origin.z)
      {
        // need to seek vertically
        dist = DistTo2(Tracer);
        dist = dist/Speed;
        if (dist < 1.0 || !dist.isfinite) dist = 1.0;
        Velocity.z = (Tracer.Origin.z+Tracer.Height/2.0-Origin.z-Height/2.0)/dist;
      }
    } else {
      // need to seek vertically
      TVec d = vector(Tracer.Origin.x-Origin.x, Tracer.Origin.y-Origin.y, 0.0);
      //dist = Length(d) > 1.0 ? Length(d) : 1.0;
      dist = fmax(1.0, Length(d));
      if (!dist.isfinite) dist = 1.0;

      // aim at a player's eyes and at the middle of the actor for everything else.
      float aimheight = Tracer.Height/2.0;
      if (Tracer.bIsPlayer) aimheight = PlayerEx(Tracer.Player).ViewHeight;
      float pitch = atan2((Tracer.Origin.z+aimheight)-(Origin.z+Height/2.0), fabs(dist));

      float xyscale = Speed*cos(pitch);
      Velocity.x = xyscale*cos(angle);
      Velocity.y = xyscale*sin(angle);
      Velocity.z = Speed*sin(pitch);
    }
  }

  return true;
}


//==========================================================================
//
//  PlayActiveSound
//
//==========================================================================
void PlayActiveSound () {
  if (ActiveSound) {
    PlaySound(ActiveSound, CHAN_VOICE, 1.0, (bFullVolActive ? ATTN_NONE : ATTN_NORMAL));
  }
}


//==========================================================================
//
//  DropItem
//
//==========================================================================
final EntityEx DropItem (class!EntityEx type, int amount, float chance, optional TVec dropofs) {
  if (Random() > chance) return none;

  float DropZ = 0.0;
  if (!Level.CompatNoTossDrops) DropZ = Height/2.0;
  if (!specified_dropofs) dropofs = vector(0.0, 0.0, DropZ);
  EntityEx A = Spawn(type, Origin+dropofs);
  //A = Spawn(type, Origin + vector(0.0, 0.0, DropZ));
  if (A.bSpecial) A.bDropped = true; // special versions of items

  if (Inventory(A)) {
    Inventory Item = Inventory(A);
    if (amount > 0) {
      Item.Amount = amount;
    } else if (Ammo(Item)) {
      // half ammo when dropped by bad guys
      if (Ammo(Item).DropAmount) {
        Item.Amount = Ammo(Item).DropAmount;
      } else {
        Item.Amount = Item.Amount/2;
        if (Item.Amount < 1) Item.Amount = 1;
      }
    } else if (Weapon(Item)) {
      // the same from dropped weapons
      if (Weapon(Item).AmmoGive1 != 0) {
        Weapon(Item).AmmoGive1 = Weapon(Item).AmmoGive1/2;
        if (Weapon(Item).AmmoGive1 < 1) Weapon(Item).AmmoGive1 = 1;
      }
      if (Weapon(Item).AmmoGive2 != 0) {
        Weapon(Item).AmmoGive2 = Weapon(Item).AmmoGive2/2;
        if (Weapon(Item).AmmoGive2 < 1) Weapon(Item).AmmoGive2 = 1;
      }
    }
    if (Item.SpecialDropAction(self)) return none;
  }

  if (!Level.CompatNoTossDrops) {
    A.Velocity.x = (Random()-Random())*35.0;
    A.Velocity.y = (Random()-Random())*35.0;
    A.Velocity.z = (5.0+Random()*4.0)*35.0;
  }

  return A;
}


//==========================================================================
//
//  NoBlockingSet
//
//==========================================================================
void NoBlockingSet () {
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float deltaTime) {
  //if (self isa PlayerPawn) print("*** PLAYERPAWN(%C): TICK!", self);

  if (bIsPlayer && GetCvarB('k8TraceDebug')) {
    auto plr = PlayerEx(Player);
    trsplat_t tr;
    TAVec ang = Angles; //vector(plr.pitch, plr.yaw, plr.roll);
    TVec dir;
    AngleVector(ang, out dir);
    bool wallHit = TraceLineEx(Origin, dir, 4096, true, &tr);
    if (wallHit) {
      print("*** WALL");
    } else if (tr.mobj) {
      print("*** thing %n: health=%d", GetClassName(tr.mobj.Class), tr.mobj.Health);
    }
  }

  Inventory Item;

  if (Level.bFrozen && ((!bIsPlayer && !bNoTimeFreeze) ||
      (bIsPlayer && !(PlayerEx(Player).Cheats&PlayerEx::CF_TIMEFREEZE))))
  {
    return;
  }

  // handle powerup effects
  for (Item = Inventory; Item && Item.Owner == self; Item = Item.Inventory) {
    Item.DoEffect();
  }

  if (bVisibilityPulse) {
    // pulse visibility in and out
    if (VisDir > 0) {
      Alpha += 0.75*deltaTime;
      if (Alpha > 1.0) {
        Alpha = 1.0;
        VisDir = -1;
      }
    } else {
      Alpha -= 0.75*deltaTime;
      if (Alpha <= 0.25) {
        Alpha = 0.25;
        VisDir = 1;
      }
    }
  } else if (bStealth) {
    // fade a stealth monster in and out of visibility
    if (GetCvarB('fuck_stealth_monsters')) {
      Alpha = 1.0;
    } else if (VisDir > 0) {
      Alpha += 2.0*deltaTime;
      if (Alpha > 1.0) {
        Alpha = 1.0;
        VisDir = 0;
      }
    } else if (VisDir < 0) {
      Alpha -= 3.0*deltaTime/2.0;
      if (Alpha < 0.0) {
        Alpha = 0.0;
        VisDir = 0;
      }
    }
  }

  if (JumpTime) {
    JumpTime -= deltaTime;
    if (JumpTime <= 0.0) JumpTime = 0.0;
  }

  if (!Physics(deltaTime)) return;

  // cycle through states, calling action functions at transitions
  if (StateTime != -1.0) {
    //if (self isa PlayerPawn) print("*** PLAYERPAWN(%C): TICK! 000", self);
    if (!AdvanceState(deltaTime)) {
      // freed itself
      //if (self isa PlayerPawn) print("*** *** PLAYERPAWN(%C): TICK! 001", self);
      return;
    }
  } else {
    // check for nightmare respawn
    if (!bAlwaysRespawn) {
      if (!bMonster || bDormant || bNeverRespawn) return;
      if (!LineSpecialGameInfo(Level.Game).RespawnTime) return;
      if (Level.World.SkillRespawnLimit > 0 &&
          SkillRespawnCount >= Level.World.SkillRespawnLimit)
      {
        return;
      }
    }

    ++MoveCount;
    if (MoveCount < int(LineSpecialGameInfo(Level.Game).RespawnTime*35.0)) return;
    if (XLevel.TicTime&31) return;
    if (P_Random() > 4) return;
    NightmareRespawn();
  }
}


//==========================================================================
//
//  SectorChanged
//
//  CrushChange == -666: loader fix
//
//==========================================================================
override bool SectorChanged (int CrushChange) {
  if (CrushChange == -666) {
    // only fix positions for monsters (and don't touch corpses too)
    if (!bMonster && !bIsPlayer) return true;
    if (!bSolid || bCorpse) return true;
  }

  if (HeightClip()) return true;

  // crunch bodies to giblets
  if (bCorpse && !bDontGib && Health <= 0) {
    bool CanDestroy = false;
    state stgibs = FindClassState(Class, 'Death', 'SectorGibs', exact:true);
    if (stgibs) {
      bDontGib = true;
      SetState(stgibs);
    } else if (!bNoBlood) {
      class c = FindClass('RealGibs');
      if (c) c = GetClassReplacement(c);
      if (c) {
        state spst = FindClassState(c, 'Spawn');
        if (!spst || !AreStateSpritesPresent(spst)) c = none;
      }

      if (c) {
        Actor Gib = Spawn(RealGibs);
        Gib.RenderStyle = RenderStyle;
        Gib.Alpha = Alpha;
        Gib.Height = 0.0;
        Gib.Radius = 0.0;
        if (BloodTranslation && !Gib.bDontTranslate) Gib.Translation = BloodTranslation;
        Gib.PlaySound('misc/fallingsplat', /*CHAN_BODY*/CHAN_AUTO);
        CanDestroy = true;
      } else {
        bDontGib = true;
      }
    }
    if (bIsPlayer) {
      bColideWithWorld = false;
      bColideWithThings = false;
      bDontGib = true;
      bInvisible = true;
    } else {
      if (CanDestroy) Destroy();
    }
    return true;
  }

  // crunch dropped items
  if (bDropped) {
    Destroy();
    return true;
  }

  // killough 11/98: kill touchy things immediately
  if (bTouchy && (bArmed || IsSentient())) {
    bArmed = false; // disarm
    SpawnExploBloodAtHead(default.Health, none);
    Damage(none, none, default.Health); // kill object
    return true;
  }

  if (!bShootable) {
    // assume it is bloody gibs or something
    return true;
  }

  if (CrushChange > 0 && !(XLevel.TicTime&3)) {
    Damage(none, none, CrushChange);
    // spray blood in a random direction
    if (!bNoBlood && !bInvulnerable && BloodType && IsBloodAllowed()) {
      EntityEx A = Spawn(BloodType, Origin+vector(0.0, 0.0, Height/2.0));
      A.SetBloodArgs(self, damage:CrushChange);
      A.Velocity.x = (Random()-Random())*16.0*35.0;
      A.Velocity.y = (Random()-Random())*16.0*35.0;
      if (BloodTranslation && !A.bDontTranslate) A.Translation = BloodTranslation;
    }
    if (!bInvulnerable && CrushPainSound && !GetSoundPlayingInfo(self, GetSoundID(CrushPainSound))) {
      PlaySound(CrushPainSound, CHAN_VOICE);
    }
  }

  return false; // don't fit
}


//==========================================================================
//
//  ClientTick
//
//==========================================================================
override void ClientTick (float DeltaTime) {
  dlight_t *dl;
  TVec fv;
  int i, c;
  float r = 0.0;
  bool alt = false;

  if (bInvisible || bNoSector) return;

  DoStateEffects(DeltaTime);

  if (bDynamicLight) {
    // update dynamic lights
    dl = AllocDlight(self, Origin, radius:fmax(0, fmax(prev_rad, DLightRadius)));
    if (dl) {
      //dl->origin = Origin;
      dl->radius = (prev_rad <= DLightRadius ? prev_rad : (prev_rad-DLightRadius)*XLevel.Time);
      dl->radius += XLevel.Time*dl->decay;
      //if (dl->radius > DLightRadius) dl->radius = DLightRadius;
      dl->radius = fmin(dl->radius, DLightRadius);
      prev_rad = dl->radius;
      dl->colour = DLightColour;
      dl->die = XLevel.Time+0.1;
    }
  }

  if (bLeaveTrail) {
    c = P_Random()>>1;
    if (P_Random() > 180) {
      r = Random()*8.0;
      alt = true;
    }
    if (GetCvarB('r_particle_trails')) {
      LineSpecialLevelInfo(Level).ParticleEffect(int(DeltaTime*256.0), alt ? LineSpecialLevelInfo::pt_explode : LineSpecialLevelInfo::pt_static, 0, Origin,
          0.0, vector(16.0, 16.0, 64.0), 0.5, 2.5, 0.0, alt ? RGB(255, 140, 0) : RGB(c, c, c), 0.5,  r);
    }
  }
  if (bLeaveTrail2) {
    c = P_Random()>>1;
    if (GetCvarB('r_particle_trails')) {
      LineSpecialLevelInfo(Level).ParticleEffect(6,
          LineSpecialLevelInfo::pt_static, 0, vector(Origin.x-(cos(Angles.yaw)*Radius*2.0),
          Origin.y-(sin(Angles.yaw)*Radius*2.0),
          Origin.z-(float(int(Height)>>3*int(Velocity.z)>>16)+2.0*Height/3.0)),
          0.0, vector(32.0, 32.0, 32.0), 0.5, 10.0, 40.0, RGB(c, c, c), 0.6, 0.0);
    }
  }
}


//==========================================================================
//
//  DoStateEffects
//
//==========================================================================
final void DoStateEffects (float DeltaTime) {
  array!(LightEffectDef *) Lights;
  array!(ParticleEffectDef *) Particles;

  GetStateEffects(Lights, Particles);
  if (!Lights.Num && !Particles.Num) return;

  TVec Forward;
  TVec Right;
  TVec Up;
  float LightTime;
  float max;

  AngleVectors(Angles, out Forward, out Right, out Up);

  if (!bStaticLightSpawned) {
    // dynamic lights
    // note that this is wrong, as entity can only have one dynlight attached
    //BeginEntityDlights(self); // this should forget all entity dlights, *AND* allow several dlights attached; noop for now
    //scope(exit) EndEntityDlights(self);
    // maybe it is better to allow any number of entity dlights, but reset all of them on new frame?
    // or give each dynlight an id, to allow replacing?
    // note that sprite effects can have several lights attached, and that can be changed with each new frame, so
    // i think that it will be better to use ids, and allow unreplaced lights to decay
    foreach (auto i; 0..Lights.length) {
      LightEffectDef *L = Lights[i];
      TVec lorg = Origin+Forward*L->Offset.x-Right*L->Offset.y+Up*L->Offset.z;
      dlight_t *dl = AllocDlight(self, lorg, radius:fmax(0, fmax(prev_rad, L->Radius)), lightid:i+1); // pass "light id" to allow replacing
      if (!dl) continue; // alas
      //print("%C: rad: %s", self, dl->radius);
      //dl->origin = Origin + Forward * L->Offset.x - Right * L->Offset.y + Up * L->Offset.z;
      switch (L->Type) {
        case DynamicLight::DLTYPE_Point:
        case DynamicLight::DLTYPE_Subtractive:
          dl->decay = XLevel.Time+300.0;
          dl->radius = (prev_rad <= L->Radius ? prev_rad : (prev_rad-L->Radius)*XLevel.Time);
          dl->radius += XLevel.Time*dl->decay;
          if (dl->radius > L->Radius) dl->radius = L->Radius;
          dl->type = L->Type;
          break;
        case DynamicLight::DLTYPE_MuzzleFlash:
          max = (L->Radius+Random()*(L->Radius2-L->Radius));
          dl->decay = XLevel.Time+80.0;
          dl->radius = (prev_rad <= L->Radius ? prev_rad : (prev_rad-L->Radius)*XLevel.Time);
          dl->radius += XLevel.Time*dl->decay;
          if (dl->radius > max) dl->radius = max;
          break;
        case DynamicLight::DLTYPE_Pulse:
          dl->decay = XLevel.Time+150.0;
          // avoid division by 0
          float PulseCycle = (L->Interval ? L->Interval/35.0 : 1.0/35.0);
          LightTime += DeltaTime;
          if (LightTime >= PulseCycle) LightTime = 0.0;
          float Frac = (1.0+sin(360.0*LightTime/PulseCycle))*0.5;
          dl->radius = L->Radius+Frac*L->Radius2-L->Radius;
          break;
        case DynamicLight::DLTYPE_Flicker:
          dl->decay = XLevel.Time+80.0;
          dl->radius = Random() >= L->Chance/360.0 ? L->Radius2 : L->Radius;
          break;
        case DynamicLight::DLTYPE_FlickerRandom:
          LightTime += DeltaTime;
          if (LightTime > L->Interval/360.0) {
            max = (L->Radius+Random()*(L->Radius2-L->Radius));
            dl->decay = XLevel.Time+80.0;
            dl->radius = prev_rad <= L->Radius ? prev_rad : (prev_rad-L->Radius)*XLevel.Time;
            dl->radius += XLevel.Time*dl->decay;
            if (dl->radius > max) dl->radius = max;
            LightTime = 0.0;
          }
          break;
        case DynamicLight::DLTYPE_Sector:
        case DynamicLight::DLTYPE_SectorSubtractive:
          {
            float Scale = L->Scale*0.125;
            if (!Scale) Scale = 1.0;
            dl->radius = float(Sector->params.lightlevel)*Scale;
            if (dl->radius < 0.0) dl->radius = 0.0;
            if (dl->radius > 255.0) dl->radius = 255.0;
            dl->type = (L->Type == DynamicLight::DLTYPE_Sector ? DynamicLight::DLTYPE_Point : DynamicLight::DLTYPE_Subtractive);
          }
          break;
      }
      dl->colour = L->Colour;
      dl->minlight = L->MinLight;
      dl->die = XLevel.Time+0.1;
      prev_rad = dl->radius;
    }
  }

  if (State != PrevEffectState) {
    // particle effects
    if (Particles.Num > 0 && GetCvarB('r_particle_effects')) {
      foreach (auto i; 0..Particles.length) {
        ParticleEffectDef *P = Particles[i];
        Level.ParticleEffect(P->Count, P->Type, P->Type2,
          Origin+Forward*P->Offset.x-Right*P->Offset.y+Up*P->Offset.z,
          P->OrgRnd, P->Velocity, P->VelRnd,
          P->Accel, P->Grav, P->Colour, P->Duration, P->Ramp);
      }
    }
    PrevEffectState = State;
  }
}


//==========================================================================
//
//  TouchDehackedSpecial
//
//==========================================================================
final void TouchDehackedSpecial (EntityEx Toucher) {
  if (!Toucher.bPickUp) return; // can't remove thing

  // dead thing touching
  // can happen with a sliding player corpse
  if (Toucher.Health <= 0) return;

  class!Inventory ItemType = LineSpecialLevelInfo(Level).GetDehackedItemType(self);
  if (!ItemType) return;

  Inventory Item = Spawn(ItemType, default, default, default, false);
  Item.bDropped = bDropped;
  if (bDropped) {
    if (Ammo(Item)) {
      // half ammo when dropped by bad guys
      Item.Amount = Item.Amount/2;
      if (Item.Amount < 1) Item.Amount = 1;
    }
  }

  if (!Item.TryPickup(Toucher)) {
    Item.Destroy();
    return;
  }

  if (Special) {
    Level.ExecuteActionSpecial(Special, Args[0], Args[1], Args[2], Args[3], Args[4], nullptr, 0, Toucher);
    Special = 0;
  }
  if (bCountItem) {
    ++Toucher.Player.ItemCount;
    ++Level.CurrentItems;
  }

  Toucher.Player.cprint("%s", Item.GetPickupMessage());
  Toucher.PlaySound(Item.PickupSound, CHAN_ITEM);

  if (bDropped) {
    Destroy();
  } else if (!Item.ShouldStay()) {
    if (Item.ShouldRespawn()) {
      bInvisible = true;
      bSpecial = false;
      SetState(FindState('DehackedDormantPickup'));
    } else {
      Destroy();
    }
  }
  PlayerEx(Toucher.Player).BonusFlash += Inventory::BONUSADD;
  // destroy item if it wasn't added to the toucher's inventory
  if (!Item.Owner) Item.Destroy();
}


//==========================================================================
//
//  GiveBody
//
//  Returns false if the body isn't needed at all
//
//==========================================================================
final bool GiveBody (int num) {
  int max;

  if (bIsPlayer) {
    max = PlayerEx(Player).GetMaxHealth();
    if (num < 0) {
      // for Strife negative body sets you to the percentage of your full health
      num = max*(-num)/100;
      if (Player.Health < num) {
        Player.Health = num;
        Health = num;
        return true;
      }
    } else if (Player.Health < max) {
      Player.Health += num;
      if (Player.Health > max) Player.Health = max;
      Health = Player.Health;
      return true;
    }
  } else {
    max = default.Health;
    if (num < 0) {
      num = max*(-num)/100;
      if (Health < num) {
        Health = num;
        return true;
      }
    } else if (Health < max) {
      Health += num;
      if (Health > max) Health = max;
      return true;
    }
  }
  return false;
}


//==========================================================================
//
//  RepairArmorWith
//
//  Returns false if the armor weren't repaired.
//
//==========================================================================
final bool RepairArmorWith (int amount, optional class!BasicArmorBonus armorbonustype) {
  // default armorbonustype: ArmorBonus
  print("WARNING: `RepairArmorWith()` is not implemeted!");
  return false;
}


//==========================================================================
//
//  SpawnPuff
//
//  to prevent decal spawning, pass 'none' as `decalType`
//  (or something else that is non-existing)
//  decalType of '' means "use default puff decal"
//
//==========================================================================
final void SpawnPuff (TVec Org, float Range, class!EntityEx PuffType,
  bool HitThing, optional sector_t *sec, optional line_t *li, optional TVec realOrg,
  optional name decalType, optional int pufftid, optional bool disableRandomZ)
{
  EntityEx puff;

  if (PuffType && PuffType.default.bPuffParticles && GetCvarB('r_particle_puffs')) {
    int c = P_Random()>>1;
    foreach (int i; 0..MAXPLAYERS) {
      if (!Level.Game.Players[i]) continue;
      if (!Level.Game.Players[i].bSpawned) continue;
      PlayerEx(Level.Game.Players[i]).ParticleEffect(20, LineSpecialLevelInfo::pt_static,
               LineSpecialLevelInfo::pt_explode2, Org, 0.0, vector(32.0, 32.0, 32.0),
               0.5, 10.0, 40.0, RGB(c, c, c), 0.8, 0.0);
    }
  }

  if (!decalType && PuffType) decalType = PuffType.default.DecalName;
  if (nameicmp(decalType, 'none') == 0) decalType = ''; // prevent error spam
  /*
  if (specified_decalType) {
    if (!decalType) doDecal = false;
  } else {
    if (!PuffType || !PuffType.default.DecalName) doDecal = false;
  }*/

  //print("SpawnPuff: Range=%s; PuffType=%C; decalType=%s(%B); puffdecal=%s; doDecal=%B", Range, PuffType, decalType, specified_decalType, (PuffType ? PuffType.default.DecalName : '<none>'), doDecal);

  if (decalType && sec && li) {
    //k8:TODO: this should be strictly client-side
    if (!specified_realOrg) realOrg = Org;
    if (specified_decalType && decalType) {
      SpawnDecal(realOrg, decalType, (sec == li->backsector ? 1 : 0), li);
    } else {
      SpawnDecal(realOrg, PuffType.default.DecalName, (sec == li->backsector ? 1 : 0), li);
    }
  }

  if (PuffType) {
    if (!disableRandomZ) Org.z += (Random()-Random())*4.0;

    puff = Spawn(PuffType, Org);
    if (!puff) return; // oops

    if (pufftid) puff.SetTID(pufftid);

    // [BB] set the target of the puff to this actor
    if (puff.bPuffGetsOwner) puff.Target = Target;
         if (!HitThing && puff.FindState('Crash')) puff.SetState(puff.FindState('Crash'));
    else if (Range == MELEERANGE && puff.MeleeState) puff.SetState(puff.MeleeState);

    if (HitThing && puff.SightSound) {
      // hit thing sound
      puff.PlaySound(puff.SightSound, CHAN_VOICE);
    } else if (puff.AttackSound) {
      puff.PlaySound(puff.AttackSound, CHAN_VOICE);
    }

    if (puff.ExplodeEffect) SendExplosion(ExplodeEffect, DLightRadius, Org);
    LineSpecialLevelInfo(Level).bPuffSpawned = true;
  }
}


//==========================================================================
//
//  SendExplosion
//
//==========================================================================
final void SendExplosion (int colour, float rad, TVec org) {
  foreach (auto i; 0..MAXPLAYERS) {
    if (!Level.Game.Players[i]) continue;
    if (!Level.Game.Players[i].bSpawned) continue;
    PlayerEx(Level.Game.Players[i]).ClientExplosion(colour, rad, org);
  }
}


//==========================================================================
//
//  AngleIncrements
//
//==========================================================================
int AngleIncrements () {
  return (bMonster ? 45 : LineSpecialGameInfo(Level.Game).NonMonsterAngleIncrements);
}


//==========================================================================
//
//  PreExplode
//
//==========================================================================
void PreExplode () {
}


//==========================================================================
//
//  GetExplodeParms
//
//==========================================================================
void GetExplodeParms (ref int damage, ref float distance, ref ubyte damageSelf) {
}


//==========================================================================
//
//  CheckBossDeath
//
//==========================================================================
final bool CheckBossDeath () {
  // make sure there is a player alive for victory
  int i;
  foreach (i; 0..MAXPLAYERS) {
    if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned && Level.Game.Players[i].Health > 0) {
      break;
    }
  }

  if (i == MAXPLAYERS) {
    // no one left alive, so do not end game
    return false;
  }

  // scan the remaining thinkers to see if all bosses are dead
  EntityEx Other;
  foreach AllThinkers(class!Thinker(Class), Other) {
    if (Other != self && Other.Class == Class && Other.Health > 0) {
      // found a living boss
      return false;
    }
  }
  return true;
}


//==========================================================================
//
//  GetSpeechIndex
//
//==========================================================================
final int GetSpeechIndex (RogueConSpeech[] List, int ID, int Num) {
  int Found = 0;
  foreach (auto i; 0..List.length) {
    if (List[i].SpeakerID == ID) {
      ++Found;
      if (Found == Num) return i+1;
    }
  }
  return 0;
}


//==========================================================================
//
//  GetSpeech
//
//==========================================================================
final int GetSpeech () {
  if (!CurrentSpeech) CurrentSpeech = 1;
  int Index = GetSpeechIndex(XLevel.LevelSpeeches, ConversationID, CurrentSpeech);
  if (Index) return Index;
  return -GetSpeechIndex(XLevel.GenericSpeeches, ConversationID, CurrentSpeech);
}


//==========================================================================
//
//  TossUpObject
//
//==========================================================================
final EntityEx TossUpObject (class!EntityEx type) {
  float randomspeed = Random()*8.0-6.0;
  EntityEx A = Spawn(type, GetCentre());
  if (A) {
    float an = AngleMod360(Angles.yaw+Random()*360.0);
    A.Angles.yaw = an;
    A.Tracer = Target;
    A.Target = self;
    A.Velocity.x = randomspeed*cos(an)*35.0;
    A.Velocity.y = randomspeed*sin(an)*35.0;
    A.Velocity.z = (12.0+Random()/8.0)*35.0;
  }
  return A;
}


//==========================================================================
//
//  SetActorProperty
//
//==========================================================================
override void SetActorProperty (int Prop, int IntVal, string StrVal) {
  switch (Prop) {
    case APROP_Health: Health = IntVal; if (bIsPlayer) Player.Health = IntVal; break;
    case APROP_Speed: Speed = float(IntVal)/65536.0*35.0; break;
    case APROP_Damage: MissileDamage = IntVal; break;
    case APROP_Alpha: Alpha = float(IntVal)/65536.0; break;
    case APROP_RenderStyle: RenderStyle = IntVal; break;
    case APROP_Ambush: bAmbush = !!IntVal; break;
    case APROP_Invulnerable: bInvulnerable = !!IntVal; break;
    case APROP_JumpZ: if (PlayerPawn(self)) PlayerPawn(self).JumpVelZ = float(IntVal)/65536.0*35.0; break;
    case APROP_ChaseGoal: bChaseGoal = !!IntVal; break;
    case APROP_Frightened: print("Frightened property is not implemented"); break;
    case APROP_Gravity: if (IntVal < 0) IntVal = 0; Gravity = float(IntVal)/65536.0; break;
    case APROP_Friendly: bFriendly = !!IntVal; break;
    case APROP_SeeSound: SightSound = name(StrVal); break;
    case APROP_AttackSound: AttackSound = name(StrVal); break;
    case APROP_PainSound: PainSound = name(StrVal); break;
    case APROP_DeathSound: DeathSound = name(StrVal); break;
    case APROP_ActiveSound: ActiveSound = name(StrVal); break;
    case APROP_SpawnHealth: if (PlayerPawn(self)) PlayerPawn(self).MaxHealth = IntVal; break;
    case APROP_Dropped: bDropped = !!IntVal; break;
    //case APROP_Species: return NameToIIndex(GetSpecies()); //HACK! keep in sync with C++ code!
    //case APROP_NameTag: return NameToIIndex(GetClassName(Class)); //HACK! keep in sync with C++ code!
    case APROP_MasterTID: if (IntVal <= 0) { Master = none; break; } Master = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Master == self) Master = none; break; //k8: allow self?
    case APROP_TargetTID: if (IntVal <= 0) { Target = none; break; } Target = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Target == self) Target = none; break; //k8: allow self?
    case APROP_TracerTID: if (IntVal <= 0) { Tracer = none; break; } Tracer = EntityEx(Level.FindMobjFromTID(IntVal, none)); if (Tracer == self) Tracer = none; break; //k8: allow self?
    //case APROP_WaterLevel: return WaterLevel;
    case APROP_ScaleX: ScaleX = float(IntVal)/65536.0; break;
    case APROP_ScaleY: ScaleY = float(IntVal)/65536.0; break;
    case APROP_Dormant: bDormant = !!IntVal; break; //k8: change state for monster?
    case APROP_Mass: Mass = max(0, IntVal); break; //k8: float?
    case APROP_Height: Height = fmax(0, float(IntVal)/65536.0); break;
    case APROP_Radius: Radius = fmax(0, float(IntVal)/65536.0); break;
    case APROP_ViewHeight:
      if (bIsPlayer) PlayerEx(Player).ViewHeight = float(IntVal)/65536.0;
      //else ViewHeight = float(IntVal)*65536.0;
      break;
    case APROP_AttackZOffset:
      if (bIsPlayer) PlayerPawn(Player.MO).AttackZOffset = float(IntVal)/65536.0;
      break;
    case APROP_Notarget: break; // no, my dear mod author, you cannot do this
    default: dprint("%C: SetActorProperty: unknown property %d", self, Prop);
  }
}


//==========================================================================
//
//  GetActorProperty
//
//==========================================================================
override int GetActorProperty (int Prop) {
  //if (Prop == APROP_SpawnHealth) print("GetActorProperty(%C, APROP_SpawnHealth)=%s", self, self.default.Health);
  switch (Prop) {
    case APROP_Health: return Health;
    case APROP_Speed: return int(Speed/35.0*65536.0);
    case APROP_Damage: return MissileDamage;
    case APROP_Alpha: return int(Alpha*65536.0);
    case APROP_RenderStyle: return RenderStyle;
    case APROP_Ambush: return bAmbush;
    case APROP_Invulnerable: return bInvulnerable;
    case APROP_JumpZ: return int(PlayerPawn(self).JumpVelZ/35.0*65536.0);
    case APROP_ChaseGoal: return bChaseGoal;
    case APROP_Frightened: return 0;
    case APROP_Gravity: return int(Gravity*65536.0);
    case APROP_Friendly: return bFriendly;
    case APROP_SpawnHealth: if (PlayerPawn(self)) return PlayerPawn(self).MaxHealth; else return self.default.Health;
    case APROP_Dropped: return bDropped;
    case APROP_Species: return NameToIIndex(GetSpecies()); //HACK! keep in sync with C++ code!
    case APROP_NameTag: return (StrifeName ? NameToIIndex(name(StrifeName)) : NameToIIndex(GetClassName(Class))); //HACK! keep in sync with C++ code!
    case APROP_MasterTID: return (Master ? Master.TID : 0);
    case APROP_TargetTID: return (Target ? Target.TID : 0);
    case APROP_TracerTID: return (Tracer ? Tracer.TID : 0);
    case APROP_WaterLevel: return WaterLevel;
    case APROP_ScaleX: return int(ScaleX*65536.0);
    case APROP_ScaleY: return int(ScaleY*65536.0);
    case APROP_Dormant: return bDormant;
    case APROP_Mass: return int(fmax(0, Mass));
    case APROP_Height: return int(Height*65536.0);
    case APROP_Radius: return int(Radius*65536.0);
    case APROP_MeleeRange: return int(MeleeRange*65536.0);
    case APROP_ViewHeight:
      if (bIsPlayer) return int(PlayerEx(Player).ViewHeight*65536.0);
      //return int(ViewHeight*65536.0);
      return int(Height/2.0*65536.0);
    case APROP_AttackZOffset:
      return int((bIsPlayer ? PlayerEx(Player).GetAttackZOfs(missile:true) : 8.0)*65536.0);
    case APROP_Notarget: return (bIsPlayer ? PlayerEx(Player).bNoTarget : 0);
  }
  dprint("%C: GetActorProperty: unknown property %d", self, Prop);
  return 0;
}


//==========================================================================
//
//  SetPlayerProperty
//
//==========================================================================
final bool SetPlayerProperty (int Prop, int Set) {
  class!Inventory InvClass = none;

  switch (Prop) {
    case PROP_FROZEN: PlayerEx(Player).bFrozen = !!Set; return true;
    case PROP_NOTARGET: PlayerEx(Player).bNoTarget = !!Set; return true;
    case PROP_INSTANTWEAPONSWITCH: PlayerEx(Player).bInstantWeaponSwitch = !!Set; return true;
    case PROP_FLY: PlayerEx(Player).bFly = !!Set; bFly = !!Set; bNoGravity = !!Set; return true;
    case PROP_TOTALLYFROZEN: PlayerEx(Player).bTotallyFrozen = !!Set; return true;
    case PROP_INVULNERABILITY: InvClass = PowerInvulnerable; break;
    case PROP_STRENGTH: InvClass = PowerStrength; break;
    case PROP_INVISIBILITY: InvClass = PowerInvisibility; break;
    case PROP_RADIATIONSUIT: InvClass = PowerIronFeet; break;
    case PROP_ALLMAP: if (Set) PlayerEx(Player).AddRevealedMap(); else PlayerEx(Player).RemoveRevealedMap(); return true;
    case PROP_INFRARED: InvClass = PowerLightAmp; break;
    case PROP_WEAPONLEVEL2: InvClass = PowerWeaponLevel2; break;
    case PROP_FLIGHT: InvClass = PowerFlight; break;
    case PROP_SPEED: InvClass = PowerSpeed; break;
    case PROP_BUDDHA: break; // no, my dear mod author, you cannot do this
    default:
      dprint("%C: SetPlayerProperty: unknown property %d", self, Prop);
      return false;
  }

  if (Set) {
    GiveInventoryType(InvClass);
  } else {
    Inventory Item = FindInventory(InvClass);
    if (Item) Item.Destroy();
  }
  return true;
}


//==========================================================================
//
//  ShouldDropItems
//
//==========================================================================
bool ShouldDropItems () {
  return true;
}


//==========================================================================
//
//  PainShootSkull
//
//  Spawn a lost soul and launch it at the target
//
//==========================================================================
final void PainShootSkull (class!Actor SpawnType, float angle, optional bool noattack, optional bool notarget) {
  EntityEx mo;
  Actor newSkull;
  float prestep;

  if (!SpawnType) SpawnType = LostSoul;
  if (nameicmp(DamageType, 'Massacre') == 0) return;

  if (Level.CompatLimitPain) {
    // count total number of skull currently on the level
    //FIXME: decorate_A_PainAttack can override this
    int count = 0;
    foreach AllThinkers(SpawnType, mo) {
      ++count;
    }
    // if there are allready 20 skulls on the level, don't spit another one
    if (count > 20) return;
  }

  // okay, there's place for another one
  prestep = 4.0+3.0*(Radius+SpawnType.default.Radius)/2.0;

  // Check whether the Lost Soul is being fired through a 1-sided
  // wall or an impassible line, or a "monsters can't cross" line.
  // If it is, then we don't allow the spawn.
  if (CheckSides(Origin+vector(prestep*cos(angle), prestep*sin(angle), 8.0))) {
    return;
  }

  newSkull = Spawn(SpawnType, Origin);

  // Check to see if the new Lost Soul's z value is above the
  // ceiling of its new sector, or below the floor. If so, kill it.
  if ((newSkull.Origin.z > (newSkull.CeilingZ-newSkull.Height)) ||
      (newSkull.Origin.z < newSkull.FloorZ))
  {
    // kill it immediately
    newSkull.Damage(self, self, 10000, forced:true);
    return;
  }

  // Check for movements.
  if (!newSkull.TryMove(newSkull.Origin+vector(
      prestep*cos(angle), prestep*sin(angle), 8.0), false))
  {
    // kill it immediately
    newSkull.Damage(self, self, 10000, forced:true);
    return;
  }

  // spawned skulls hate same things as master
  newSkull.CopyFriendliness(self, !notarget);

  if (!noattack) newSkull.A_SkullAttack();
}


//==========================================================================
//
//  AutoUseHealth
//
//==========================================================================
final void AutoUseHealth (int saveHealth) {
  int count;
  int normalhealth = 0;
  int superhealth = 0;
  array!Inventory normal;
  array!Inventory super;
  int saved = 0;

  for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
    if (inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup)) {
      int mode = HealthPickup(inv).AutoUseMode;
      if (mode == 1) {
        normal[normal.Num] = inv;
        normal.Num = normal.Num+1;
      } else if (mode == 2) {
        super[super.Num] = inv;
        super.Num = super.Num+1;
      }
    }
  }

  foreach (auto i; 0..normal.Num-1) normalhealth += normal[i].Amount*normal[i].Health;
  foreach (auto i; 0..super.Num-1) superhealth += super[i].Amount*super[i].Health;

  if (Level.World.bSkillAutoUseHealth && normalhealth >= saveHealth) {
    // use quartz flasks
    while (normal.Num > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..normal.Num-1) {
        if (normal[i].Health > maxhealth) {
          index = i;
          maxhealth = normal[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--normal[index].Amount)) {
          // used last of a type, compact the artifact list
          normal[index].Destroy();
        }
      }
    }

    Health += saved;
  } else if (superhealth >= saveHealth) {
    // Use mystic urns
    while (super.Num > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..super.Num-1) {
        if (super[i].Health > maxhealth) {
          index = i;
          maxhealth = super[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen.
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--super[index].Amount)) {
          // used last of a type, compact the artifact list
          super[index].Destroy();
        }
      }
    }

    Health += saved;
  } else if (Level.World.bSkillAutoUseHealth && normalhealth+superhealth >= saveHealth) {
    // use mystic urns and quartz flasks
    while (normal.Num > 0 && saveHealth > 0) {
      int maxhealth = 0;
      int index = -1;

      // find the largest item in the list
      foreach (auto i; 0..normal.Num-1) {
        if (normal[i].Health > maxhealth) {
          index = i;
          maxhealth = normal[i].Health;
        }
      }

      // now apply the health items, using the same logic as Heretic and Hexen
      count = (saveHealth+maxhealth-1)/maxhealth;
      foreach (auto i; 0..count) {
        saved += maxhealth;
        saveHealth -= maxhealth;
        if (!(--normal[index].Amount)) {
          // used last of a type, compact the artifact list
          normal[index].Destroy();
        }
      }
    }

    Health += saved;
    if (saveHealth > 0) {
      while (super.Num > 0 && saveHealth > 0) {
        int maxhealth = 0;
        int index = -1;

        // find the largest item in the list
        foreach (auto i; 0..super.Num-1) {
          if (super[i].Health > maxhealth) {
            index = i;
            maxhealth = super[i].Health;
          }
        }

        // now apply the health items, using the same logic as Heretic and Hexen
        count = (saveHealth+maxhealth-1)/maxhealth;
        foreach (auto i; 0..count) {
          saved += maxhealth;
          saveHealth -= maxhealth;
          if (!(--super[index].Amount)) {
            // used last of a type, compact the artifact list
            super[index].Destroy();
          }
        }
      }

      Health += saved;
    }
  }
  Player.Health = Health;
}


//==========================================================================
//
//  AutoUseStrifeHealth
//
//==========================================================================
final void AutoUseStrifeHealth (int saveHealth) {
  array!Inventory Items;
  int itemshealth;

  for (Inventory inv = Inventory; inv; inv = inv.Inventory) {
    if (inv && inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup)) {
      int mode = HealthPickup(inv).AutoUseMode;
      if (mode == 3) {
        Items.Num = Items.Num+1;
        Items[Items.Num-1] = inv;
      }
    }
  }

  foreach (auto i; 0..Items.Num) itemshealth += Items[i].Amount*Items[i].Health;

  while (Items.Num > 0) {
    int maxhealth = 0;
    int index = -1;

    // find the largest item in the list
    foreach (auto i; 0..Items.Num) {
      if (Items[i].Health > maxhealth) {
        index = i;
        maxhealth = Items[i].Amount;
      }
    }

    while (Health < 50) {
      if (!UseInventory(Items[index])) break;
    }
    if (Health >= 50) {
      Player.Health = Health;
      return;
    }

    // using all of this item was not enough so delete it and restart with the next best one
    Items[index] = none;
    if (index < Items.Num) {
      for (int i = Items.Num-index; i < Items.Num-1; ++i) Items[i] = Items[i+1];
    }
    Items.Num -= 1;
  }

  Player.Health = Health;
}


//==========================================================================
//
//  AutoUseArmor
//
//==========================================================================
final void AutoUseArmor () {
  Inventory Item = FindInventory(MetalArmor);
  if (Item) {
    // use metal armor
    Item.Use(false);
    if (!(--Item.Amount)) Item.Destroy();
  } else {
    Item = FindInventory(LeatherArmor);
    if (Item) {
      // use leather armor
      Item.Use(false);
      if (!(--Item.Amount)) Item.Destroy();
    }
  }
}


//==========================================================================
//
//  HITDICE
//
//  Most damage in HERETIC and HEXEN defined using HITDICE
//
//==========================================================================
final int HITDICE (int a) {
  return (1+(P_Random()&7))*a;
}


//==========================================================================
//
//  SpawnDirt
//
//  Dirt stuff
//
//==========================================================================
final void SpawnDirt (float radius) {
  TVec org;
  class!EntityEx dtype;

  float angle = 360.0*Random();
  org.x = Origin.x+radius*cos(angle);
  org.y = Origin.y+radius*sin(angle);
  org.z = Origin.z+Random()*2.0+1.0;
  switch (P_Random()%6) {
    case 0: dtype = Dirt1; break;
    case 1: dtype = Dirt2; break;
    case 2: dtype = Dirt3; break;
    case 3: dtype = Dirt4; break;
    case 4: dtype = Dirt5; break;
    case 5: dtype = Dirt6; break;
  }
  EntityEx dirt = Spawn(dtype, org);
  if (dirt) dirt.Velocity.z = Random()*4.0*35.0;
}


//===========================================================================
//
//  GunShot
//
//===========================================================================
final void GunShot (int accurate, TVec dir, name DmgType, bool secondary, optional name DecalName, optional float range) {
  int damage;

  if (!specified_range || range <= 0) range = MISSILERANGE;

  // make a copy of angles because inacurate shoot will modify them
  if (!accurate) {
    TAVec angles;
    VectorAngles(dir, out angles);
    angles.yaw = AngleMod360(angles.yaw+(Random()-Random())*45.0/8.0);
    AngleVector(angles, out dir);
  }

  damage = 5*(P_Random()%3+1);
  LineAttack(dir, range, damage, BulletPuff, default, default, DmgType, secondary, DecalName!optional);
}


//===========================================================================
//
//  IsMissile
//
//===========================================================================
final bool IsMissile (bool Precise) {
  return bMissile || (Precise && default.bMissile);
}


//===========================================================================
//
//  k8CheckIfSpecialStateLabel
//
//===========================================================================
final bool k8CheckIfSpecialStateLabel (name Label) {
  if (!Label) return true; // why not?
  if (GetCvarB('_decorate_dont_warn_about_invalid_labels')) return true;
  string lbl = string(Label);
  return (stricmp(lbl, "none") == 0 || stricmp(lbl, "null") == 0 ||
          stricmp(lbl, "nil") == 0 || stricmp(lbl, "empty") == 0);
}


//===========================================================================
//
//  FindJumpState
//
//  used in decorate code to resolve jump-labels-as-arguments
//  gzshit just skips jump when invalid state name provided,
//  but i don't care what gzshit does, really.
//  i'll try to spam console with invalid label name, though
//
//===========================================================================
final state FindJumpState (name Label) {
  if (XLevel.StateCall) {
    state st = XLevel.StateCall->Item.FindState(Label);
    if (!st && !k8CheckIfSpecialStateLabel(Label)) print("WARNING: unknown decorate label (statecall) '%s' -- probably broken actor '%C' code!", Label, self);
    return st;
  }
  if (bIsPlayer) {
    if (XLevel.CallingState == Player.ViewStates[ps_weapon].State) {
      if (!PlayerEx(Player).ReadyWeapon) return none;
      state res = PlayerEx(Player).ReadyWeapon.FindState(Label);
      if (!res && !k8CheckIfSpecialStateLabel(Label)) print("WARNING: unknown decorate label (ps_weapon) '%s' -- probably broken actor '%C' code!", Label, PlayerEx(Player).ReadyWeapon);
      return res;
    }
    if (XLevel.CallingState == Player.ViewStates[ps_flash].State) {
      if (!PlayerEx(Player).ReadyWeapon) return none;
      state res = PlayerEx(Player).ReadyWeapon.FindState(Label);
      if (!res && !k8CheckIfSpecialStateLabel(Label)) print("WARNING: unknown decorate label (ps_flash) '%s' -- probably broken actor '%C' code!", Label, PlayerEx(Player).ReadyWeapon);
      return res;
    }
  }
  state res = FindState(Label);
  if (!res && !k8CheckIfSpecialStateLabel(Label)) print("WARNING: unknown decorate label '%s' -- probably broken actor '%C' code!", Label, self);
  return res;
}


//===========================================================================
//
//  DoJump
//
//  mostly called from decorate actions
//
//===========================================================================
final void DoJump (state State) {
  if (XLevel.StateCall) {
    XLevel.StateCall->State = State;
  } else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[ps_weapon].State) {
    PlayerEx(Player).SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
    Player.SetViewState(ps_weapon, State);
  } else if (bIsPlayer && XLevel.CallingState == Player.ViewStates[ps_flash].State) {
    PlayerEx(Player).SetViewObjectIfNone(PlayerEx(Player).ReadyWeapon);
    Player.SetViewState(ps_flash, State);
  } else {
    SetState(State);
  }
}


//==========================================================================
//
//  CheckForSectorActions
//
//==========================================================================
override void CheckForSectorActions (sector_t *OldSec, bool OldAboveFakeFloor, bool OldAboveFakeCeiling) {
  // check for crossing fake floor or ceiling
  if (OldSec->heightsec && Sector->heightsec && Sector->ActionList) {
    float EyeZ = (bIsPlayer ? Player.ViewOrg.z : Origin.z+Height*0.5);
    float FakeZ = GetPlanePointZ(ref Sector->heightsec->floor, Origin);

    if (!OldAboveFakeFloor && EyeZ > FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
    } else if (OldAboveFakeFloor && EyeZ <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesDive);
    }

    if (!Sector->heightsec->bFakeFloorOnly) {
      FakeZ = GetPlanePointZ(ref Sector->heightsec->ceiling, Origin);
      if (!OldAboveFakeCeiling && EyeZ > FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
      } else if (OldAboveFakeCeiling && EyeZ <= FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesBelowC);
      }
    }
  }

  // check for sector change triggers
  if (OldSec != Sector) {
    if (OldSec->ActionList) {
      SectorAction(OldSec->ActionList).TriggerAction(self, SectorAction::SECSPAC_Exit);
    }
    if (Sector->ActionList) {
      int Spac = SectorAction::SECSPAC_Enter;
      if (Origin.z <= GetPlanePointZ(ref Sector->floor, Origin)) Spac |= SectorAction::SECSPAC_HitFloor;
      if (Origin.z+Height >= GetPlanePointZ(ref Sector->ceiling, Origin)) Spac |= SectorAction::SECSPAC_HitCeiling;
      if (Sector->heightsec && Origin.z == GetPlanePointZ(ref Sector->heightsec->floor, Origin)) Spac |= SectorAction::SECSPAC_HitFakeFloor;
      SectorAction(Sector->ActionList).TriggerAction(self, Spac);
    }
  }
}


//==========================================================================
//
//  CheckFakeFloorTriggers
//
//==========================================================================
final void CheckFakeFloorTriggers (float OldZ, optional bool OldHasViewH) {
  if (Sector && Sector->heightsec && Sector->ActionList) {
    float ViewH = (bIsPlayer ? PlayerEx(Player).ViewHeight : Height*0.5);
    float FakeZ = GetPlanePointZ(ref Sector->heightsec->floor, Origin);

    if (OldZ > FakeZ && Origin.z <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_HitFakeFloor);
    }

    float EyeZ = Origin.z+ViewH;
    if (!OldHasViewH) OldZ += ViewH;

    if (OldZ <= FakeZ && EyeZ > FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesSurface);
    } else if (OldZ > FakeZ && EyeZ <= FakeZ) {
      SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesDive);
    }

    if (!Sector->heightsec->bFakeFloorOnly) {
      FakeZ = GetPlanePointZ(ref Sector->heightsec->ceiling, Origin);
      if (OldZ <= FakeZ && EyeZ > FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesAboveC);
      } else if (OldZ > FakeZ && EyeZ <= FakeZ) {
        SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_EyesBelowC);
      }
    }
  }
}


//==========================================================================
//
//  UseLines
//
//  Looks for special lines in front of the actor to activate
//
//==========================================================================
final bool UseLines (float UseRange, float UseThingRange, name FailSound) {
  bool action;
  float x1;
  float y1;
  float x2;
  float y2;
  TVec useDir;
  intercept_t *in;
  TVec hit_point;
  opening_t *open;

  action = false;
  AngleVector(Angles, out useDir);
  x1 = Origin.x;
  y1 = Origin.y;

  x2 = x1+UseThingRange*useDir.x;
  y2 = y1+UseThingRange*useDir.y;
  foreach PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES|PT_ADDTHINGS/*|PT_EARLYOUT*/) {
    if (!in->bIsALine) {
      // check height
      if (Origin.z >= in->Thing.Origin.z+in->Thing.Height ||
          Origin.z+Height <= in->Thing.Origin.z)
      {
        continue;
      }
      // don't use self
      if (in->Thing != self && UseThing(EntityEx(in->Thing))) {
        action = true;
        break;
      }
      continue;
    }

    if (!(in->line->flags&ML_TWOSIDED)) break; // stop

    hit_point = Origin+(UseThingRange*in->frac)*useDir;
    open = LineOpenings(in->line, hit_point);
    open = FindOpening(open, hit_point.z, hit_point.z+Height);
    if (!open || open->range < 1.0) break; // can't use through a wall
    continue;
  }

  x2 = x1+UseRange*useDir.x;
  y2 = y1+UseRange*useDir.y;
  bool DoSecAct = true;
  bool FoundLine = false;
  foreach PathTraverse(in, x1, y1, x2, y2, PT_ADDLINES) {
    line_t *line;
    float pheight;

    line = in->line;
    if (!line->special || (!(line->SpacFlags&(SPAC_Use|SPAC_UseThrough|SPAC_UseBack)))) {
      hit_point = Origin+(UseRange*in->frac)*useDir;
      if (line->flags&(ML_BLOCKEVERYTHING|ML_BLOCKUSE)) {
        // gozzo does this
        open = nullptr;
      } else {
        open = LineOpenings(line, hit_point);
        open = FindOpening(open, hit_point.z, hit_point.z+Height);
      }
      if (!open || open->range <= 0.0 || (line->special && Level.CompatUseBlocking)) {
        DoSecAct = false;

        // let sector intercept the use
        if (Sector && Sector->ActionList && SectorAction(Sector->ActionList).TriggerAction(self, SectorAction::SECSPAC_Use)) {
          break;
        }

        sector_t *Sec = (PointOnPlaneSide(Origin, *line) == 0 ? line->frontsector : line->backsector);
        if (Sec && Sec->ActionList && SectorAction(Sec->ActionList).TriggerAction(self, SectorAction::SECSPAC_UseWall)) {
          break;
        }

        PlaySound(FailSound, CHAN_VOICE);

        // can't use through a wall
        break;
      }
      // not a special line, but keep checking
      pheight = Origin.z+Height/2.0;
      if (open->top < pheight || open->bottom > pheight) PlaySound(FailSound, CHAN_VOICE);
      FoundLine = true;
      continue;
    }

    if (PointOnPlaneSide(Origin, *line) == 1) {
      if (!(line->SpacFlags&SPAC_UseBack)) continue;
      //k8: gozzo doesn't check this, but we'll do
      // don't use back side unless it's a two-sided line
      if (line->backsector != nullptr) continue;
      LineSpecialLevelInfo(Level).ActivateLine(line, self, 1, SPAC_UseBack);
      action = true;
    } else {
      if (line->SpacFlags&(SPAC_UseBack|SPAC_Use|SPAC_UseThrough) == SPAC_UseBack) continue; // can't be used from front, skip it
      LineSpecialLevelInfo(Level).ActivateLine(line, self, 0, SPAC_Use);
      action = true;
    }

    //WAS can't use more than one special line in a row
    //jff 3/21/98 NOW multiple use allowed with enabling line flag
    if (Level.CompatUseBlocking) {
      if (!(line->SpacFlags&SPAC_UseThrough)) {
        DoSecAct = false;
        break;
      }
    } else if (line->SpacFlags&SPAC_Use) {
      DoSecAct = false;
      break;
    }
  }

  if (DoSecAct && Sector->ActionList) {
    // Let sector intercept the use
    int Spac = SectorAction::SECSPAC_Use;
    if (FoundLine) Spac |= SectorAction::SECSPAC_UseWall;
    SectorAction(Sector->ActionList).TriggerAction(self, Spac);
  }

  return action;
}


//==========================================================================
//
//  UseThing
//
//==========================================================================
bool UseThing (EntityEx Other) {
  if (Other.bNoInteraction) return false; //k8: just in case

  //print("UseThing000: self=%C; Other=%C; Other.bUseSpecial=%s; Other.Special=%s", self, Other, Other.bUseSpecial, Other.Special);
  if (Other.bUseSpecial && Other.Special) {
    auto swd = SwitchableDecoration(Other);
    if (swd && swd.ActivationType) {
      print("***WARNING: activation type for thing specials aren't implemented yet! %C:ActivationType=0x%08x", Other, swd.ActivationType);
    }
    if (Level.ExecuteActionSpecial(
      Other.Special, Other.Args[0], Other.Args[1], Other.Args[2],
      Other.Args[3], Other.Args[4], nullptr, 0, self))
    {
      if (swd && (swd.ActivationType&SwitchableDecoration::AF_ClearSpecial)) { Other.Special = 0; foreach (ref auto v; Other.Args) v = 0; }
      return true;
    }
  }
  if (Other.bUseSpecial) {
    auto swd = SwitchableDecoration(Other);
    if (swd && swd.ActivationType) {
      //print("UseThing001: SWD! self=%C; Other=%C", self, Other);
      if (swd.Activate(self)) return true;
    }
  }
  //print("UseThing002: self=%C; Other=%C", self, Other);
  return LineSpecialLevelInfo(Level).StartConversation(self, Other);
}


//==========================================================================
//
//  IsSentient
//
//  killough 11/98:
//  Whether an object is "sentient" or not.
//  Used for environmental influences.
//
//==========================================================================
final bool IsSentient () {
  return Health > 0 && SeeState;
}


//==========================================================================
//
//  IsFast
//
//==========================================================================
final bool IsFast () {
  if (bAlwaysFast) return true;
  if (bNeverFast) return false;
  return (Level.Game.fastparm == 1);
}


//==========================================================================
//
//  RespawnResetFlags
//
//  Reset most of the flags to the default values on respawn.
//
//==========================================================================
void RespawnResetFlags () {
  //k8: restore these too
  RenderStyle = default.RenderStyle;
  Alpha = default.Alpha;
  Translation = default.Translation;
  StencilColour = default.StencilColour;
  FloorClip = default.FloorClip;
  ScaleX = default.ScaleX;
  ScaleY = default.ScaleY;

  bSpecial = default.bSpecial;
  bSolid = default.bSolid;
  bShootable = default.bShootable;
  bAmbush = default.bAmbush;
  bJustHit = default.bJustHit;
  bJustAttacked = default.bJustAttacked;
  bSpawnCeiling = default.bSpawnCeiling;
  bNoGravity = default.bNoGravity;
  bDropOff = default.bDropOff;
  bPickUp = default.bPickUp;
  bFloat = default.bFloat;
  bMissile = default.bMissile;
  bDropped = default.bDropped;
  bShadow = default.bShadow;
  bNoBlood = default.bNoBlood;
  bCorpse = default.bCorpse;
  bInFloat = default.bInFloat;
  bCountKill = default.bCountKill;
  bCountItem = default.bCountItem;
  bSkullFly = default.bSkullFly;
  bNoDeathmatch = default.bNoDeathmatch;
  bSpawnSoundSource = default.bSpawnSoundSource;
  bNoLiftDrop = default.bNoLiftDrop;
  bStealth = default.bStealth;
  bIceCorpse = default.bIceCorpse;

  bDontReflect = default.bDontReflect;
  bWindThrust = default.bWindThrust;
  bBlasted = default.bBlasted;
  bFly = default.bFly;
  bFloorClip = default.bFloorClip;
  bSpawnFloat = default.bSpawnFloat;
  bNoTeleport = default.bNoTeleport;
  bRip = default.bRip;
  bPushable = default.bPushable;
  bSlide = default.bSlide;
  bOnMobj = default.bOnMobj;
  bPassMobj = default.bPassMobj;
  bCannotPush = default.bCannotPush;
  bThruGhost = default.bThruGhost;
  bBoss = default.bBoss;
  bDontTranslate = default.bDontTranslate;
  bNoDamageThrust = default.bNoDamageThrust;
  bTelestomp = default.bTelestomp;
  bFloatBob = default.bFloatBob;
  bActivateImpact = default.bActivateImpact;
  bActivatePushWall = default.bActivatePushWall;
  bActivateMCross = default.bActivateMCross;
  bActivatePCross = default.bActivatePCross;
  bCantLeaveFloorpic = default.bCantLeaveFloorpic;
  bNonShootable = default.bNonShootable;
  bInvulnerable = default.bInvulnerable;
  bSeekerMissile = default.bSeekerMissile;
  bReflective = default.bReflective;

  bIgnoreFloorStep = default.bIgnoreFloorStep;
  bIgnoreCeilingStep = default.bIgnoreCeilingStep;
  bNoRadiusDamage = default.bNoRadiusDamage;
  bGhost = default.bGhost;
  bAlwaysPuff = default.bAlwaysPuff;
  bNoSplash = default.bNoSplash;
  bDontOverlap = default.bDontOverlap;
  bNoMorph = default.bNoMorph;
  bDontSquash = default.bDontSquash;
  bFullVolActive = default.bFullVolActive;
  bMonster = default.bMonster;
  bExplodeOnSky = default.bExplodeOnSky;
  bStayMorphed = default.bStayMorphed;
  bDontBlast = default.bDontBlast;
  bCanBlast = default.bCanBlast;
  bNeverTarget = default.bNeverTarget;
  bDontGib = default.bDontGib;
  bNoBlockMonst = default.bNoBlockMonst;
  bFullVolDeath = default.bFullVolDeath;
  bCanBounceWater = default.bCanBounceWater;
  bNoWallBounceSnd = default.bNoWallBounceSnd;
  bDamageInvulnerable = default.bDamageInvulnerable;
  bNoTeleOther = default.bNoTeleOther;
  bBloodlessImpact = default.bBloodlessImpact;
  bNoExplodeFloor = default.bNoExplodeFloor;
  bPuffOnActors = default.bPuffOnActors;

  bNoGrudge = default.bNoGrudge;
  bNoIceDeath = default.bNoIceDeath;
  bBossDeath = default.bBossDeath;
  bRandomise = default.bRandomise;
  bActLikeBridge = default.bActLikeBridge;
  bStrifeDamage = default.bStrifeDamage;
  bTriggerHappy = default.bTriggerHappy;
  bMissileEvenMore = default.bMissileEvenMore;
  bForceRadiusDmg = default.bForceRadiusDmg;
  bNoGravKill = default.bNoGravKill;
  bInCombat = default.bInCombat;
  bLookAllAround = default.bLookAllAround;
  bStanding = default.bStanding;
  bSpectral = default.bSpectral;
  bFireResist = default.bFireResist;
  bSynchronised = default.bSynchronised;
  bNoTargetSwitch = default.bNoTargetSwitch;
  bDontHurtSpecies = default.bDontHurtSpecies;
  bShieldReflect = default.bShieldReflect;
  bDeflect = default.bDeflect;
  bPuffParticles = default.bPuffParticles;
  bNoExtremeDeath = default.bNoExtremeDeath;
  bExtremeDeath = default.bExtremeDeath;
  bNoBounceSound = default.bNoBounceSound;

  bFaster = default.bFaster;
  bFastMelee = default.bFastMelee;
  bNoDropOff = default.bNoDropOff;
  bBounceOnActors = default.bBounceOnActors;
  bExplodeOnWater = default.bExplodeOnWater;
  bAvoidingDropoff = default.bAvoidingDropoff;
  bNoDamage = default.bNoDamage;
  bChaseGoal = default.bChaseGoal;
  bPierceArmor = default.bPierceArmor;
  bNoPain = default.bNoPain;
  bAlwaysFast = default.bAlwaysFast;
  bNeverFast = default.bNeverFast;
  bCanUseWalls = default.bCanUseWalls;

  DecalName = default.DecalName;
}


//==========================================================================
//
//  CalcFakeZMovement
//
//==========================================================================
override void CalcFakeZMovement (out TVec Ret, float DeltaTime) {
  // adjust height
  Ret = Origin;
  Ret.z += Velocity.z*DeltaTime;
  if (bFloat && Target) {
    // float down towards enemy if too close
    if (!bSkullFly && !bInFloat) {
      float dist = DistTo2(Target);
      float delta = Target.Origin.z+Height/2.0-Ret.z;
      if (delta < 0.0 && dist < -(delta*3.0)) {
        Ret.z -= FloatSpeed*DeltaTime;
      } else if (delta > 0.0 && dist < (delta*3.0)) {
        Ret.z += FloatSpeed*DeltaTime;
      }
    }
  }
  if (bIsPlayer && bFly && !(Ret.z <= FloorZ) && (XLevel.TicTime&2)) {
    //FIXME: k8 i made this time-dependent, rewrite!
    //       for now, i restored jerky movement
    Ret.z += sin(90.0*35.0/20.0*AngleMod360(XLevel.Time));
  }
}


//===========================================================================
//
//  DoThingRaise
//
//===========================================================================
final bool DoThingRaise () {
  if (!bCorpse) return false; // not a monster

  if (StateTime != -1.0) {
    // not lying still yet; check frame flag
    if (!State) return false;
    if ((GetStateSpriteFrame(State)&FF_CANRAISE) == 0) return false;
  }

  state RaiseState = FindState('Raise');
  if (!RaiseState) return false; // monster doesn't have a raise state

  Velocity.x = 0.0;
  Velocity.y = 0.0;
  float OldHeight = Height;
  float OldRadius = Radius;
  bool OldSolid = bSolid;
  bSolid = true;
  Height = default.Height;

  if (!CheckPosition(Origin)) {
    Height = OldHeight;
    Radius = OldRadius;
    bSolid = OldSolid;
    return false; // doesn't fit here
  }

  PlaySound('vile/raise', /*CHAN_BODY*/CHAN_AUTO);

  SetState(RaiseState);
  bShootable = true;
  bFloat = default.bFloat;
  bNoGravity = default.bNoGravity;
  bDropOff = false;
  bSolid = true;
  bCorpse = false;
  Health = default.Health;
  Target = none;
  LastEnemy = none;

  // if it counts as kill, count it as another one
  if (CountsAsKill()) ++Level.TotalKills;
  return true;
}


//==========================================================================
//
//  GetInfighting
//
//==========================================================================
final int GetInfighting () {
  if (bNoInfighting) return -1;
  if (Level.Infighting) return Level.Infighting;
  return GetCvar('infighting');
}


//==========================================================================
//
//  IsFriend
//
//==========================================================================
final bool IsFriend (EntityEx Other) {
  if (!Other) return false;
  if (bFriendly && Other.bFriendly) {
    return !Level.Game.deathmatch || FriendPlayer == Other.FriendPlayer ||
           FriendPlayer == 0 || Other.FriendPlayer == 0;
  }
  return false;
}


//==========================================================================
//
//  IsHostile
//
//==========================================================================
final bool IsHostile (EntityEx Other) {
  if (!Other) return false;
  // if bot monsters are not friendles, hostiles depend on infighting.
  if (!bFriendly && !Other.bFriendly) return false;

  if (bFriendly && Other.bFriendly) {
    return Level.Game.deathmatch && FriendPlayer != Other.FriendPlayer &&
           FriendPlayer != 0 && Other.FriendPlayer != 0;
  }
  return true;
}


//==========================================================================
//
//  ClassifyActor
//
//==========================================================================
override int ClassifyActor () {
  int Ret = 0;
  if (bIsPlayer) {
    Ret |= ACTOR_PLAYER;
    Ret |= (Player.PlayerState == PST_DEAD ? ACTOR_DEAD : ACTOR_ALIVE);
    if (Player.MO != self) Ret |= ACTOR_VOODOODOLL;
    if (Player.bIsBot) Ret |= ACTOR_BOT;
  } else if (bMonster) {
    Ret |= ACTOR_MONSTER;
    Ret |= (Health <= 0 ? ACTOR_DEAD : ACTOR_ALIVE);
  } else if (bMissile) {
    Ret |= ACTOR_MISSILE;
  } else {
    Ret |= ACTOR_GENERIC;
  }
  return Ret;
}


//==========================================================================
//
//  CountsAsKill
//
//==========================================================================
final bool CountsAsKill () {
  return bCountKill && !bFriendly;
}


//==========================================================================
//
//  GetViewEntRenderParams
//
//==========================================================================
override void GetViewEntRenderParams (ref float OutAlpha, ref int OutRenderStyle) {
  if (Inventory) {
    Inventory.GetViewEntRenderParams(OutAlpha, OutRenderStyle);
  }
}


//==========================================================================
//
//  CopyFriendliness
//
//==========================================================================
void CopyFriendliness (EntityEx Src, bool ChangeTarget) {
  Level.TotalKills -= CountsAsKill();
  TIDToHate = Src.TIDToHate;
  LastLook = Src.LastLook;
  LastLookActor = Src.LastLookActor;
  bFriendly = Src.bFriendly;
  bNoSightCheck = Src.bNoSightCheck;
  bHuntPlayers = Src.bHuntPlayers;
  bNoHatePlayers = Src.bNoHatePlayers;
  FriendPlayer = Src.FriendPlayer;
  Level.TotalKills += CountsAsKill();
  if (ChangeTarget && Src.Target && !Src.Target.bNeverTarget) {
    Target = Src.Target;
    LastHeard = Src.Target;
  }
}


//==========================================================================
//
//  IsTeammate
//
//==========================================================================
bool IsTeammate (EntityEx Other) {
  return bIsPlayer && Other.bIsPlayer && Level.Game.netgame && !Level.Game.deathmatch;
}


//==========================================================================
//
//  IsNotAttackingMaster
//
//==========================================================================
bool IsNotAttackingMaster (EntityEx Other) {
  return false;
}


//==========================================================================
//
//  IsMaster
//
//==========================================================================
bool IsMaster (EntityEx Other) {
  return false;
}


//==========================================================================
//
//  IsServant
//
//==========================================================================
bool IsServant () {
  return false;
}


//==========================================================================
//
//  TouchSpecial
//
//==========================================================================
void TouchSpecial (EntityEx Toucher, optional bool noflash) {
}


//==========================================================================
// Flags for A_JumpIfTargetInLOS and A_JumpIfInTargetLOS
//enum EJumpFlags
//!NOT_IMPLEMENTED!const int JLOSF_PROJECTILE =    1;
const int JLOSF_NOSIGHT =     1<<1;
//!NOT_IMPLEMENTED!const int JLOSF_CLOSENOFOV =    1 << 2;
//!NOT_IMPLEMENTED!const int JLOSF_CLOSENOSIGHT =  1 << 3;
//!NOT_IMPLEMENTED!const int JLOSF_CLOSENOJUMP =   1 << 4;
const int JLOSF_DEADNOJUMP = 1<<5;
const int JLOSF_CHECKMASTER = 1<<6;
//!NOT_IMPLEMENTED!const int JLOSF_TARGETLOS =   1 << 7;
//!NOT_IMPLEMENTED!const int JLOSF_FLIPFOV =     1 << 8;
const int JLOSF_ALLYNOJUMP =    1<<9;
//!NOT_IMPLEMENTED!const int JLOSF_COMBATANTONLY = 1 << 10;
//!NOT_IMPLEMENTED!const int JLOSF_NOAUTOAIM =   1 << 11;
//!NOT_IMPLEMENTED!const int JLOSF_CHECKTRACER =   1 << 12;
//};


//==========================================================================
//
//  checkIfTargetInLOS
//
//  workhorse for following decorate LOS checks
//
//==========================================================================
final bool checkIfTargetInLOS (optional float Fov, optional int flags, optional float distmax, optional float distclose) {
  if (distmax == 0) distmax = 8192;
  Fov = fabs(Fov);

  EntityEx Targ;
  if (!bIsPlayer) {
    Targ = (flags&JLOSF_CHECKMASTER ? Master : Target);
    if (!Targ) return false;
    if (!(flags&JLOSF_NOSIGHT)) {
      if (!CanSee(Targ)) return false;
    }
    if (Fov && Fov < 360.0) {
      float Ang = AngleMod180(atan2(Targ.Origin.y-Origin.y, Targ.Origin.x-Origin.x)-Angles.yaw);
      if (fabs(Ang) > Fov/2.0) return false;
    }
  } else {
    TVec Dir;
    //Targ = Aim(Dir, distmax/*16.0*64.0*/); // old code
    bool noAAim = !PlayerEx(self).bAutoAim, noAAVert = false;
    Weapon Wpn = PlayerEx(self).ReadyWeapon;
    if (Wpn && Wpn.IsAutoaimDisabled()) noAAim = true; //bNoAutoaim;
    noAAVert = noAAim;
    Targ = Aim(nullptr, 8192/*16*64*/, Angles.yaw, noAutoaim:noAAim, noVertAutoAim:noAAVert);
  }

  if (Targ) {
    if ((flags&JLOSF_DEADNOJUMP) && Targ.Health <= 0) return false;
    if (flags&JLOSF_ALLYNOJUMP) {
      //FIXME: incomplete
      if (Targ == self || (bIsPlayer && Targ.bFriendly)) return false;
    }
    return true;
  }

  return false;
}


// ////////////////////////////////////////////////////////////////////////// //
states {
DehackedDormantPickup:
  TNT1 A 1050
  TNT1 A -1
  {
    EntityEx  A;

    bInvisible = false;
    bSpecial = true;
    SetState(IdleState);

    // spawn a teleport fog at the new spot
    A = Spawn(ItemFog, Origin);
    A.PlaySound('misc/spawn', CHAN_ITEM);
  }
  Stop
}
