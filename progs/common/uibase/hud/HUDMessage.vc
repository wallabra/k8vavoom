//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2019 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, either version 3 of the License, or
//**  (at your option) any later version.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class HUDMessage : Widget;

// ID, used as a priority or to replace a previous message.
int Id;
int ticStart; // do not start message before this tic

string oldtext;
name oldfont;

array!SplitLine MsgLines;
name MsgFont;
int MsgColour;
float MsgAlpha;

// calculated size of the message box
int MsgWidth;
int MsgHeight;

// message location
float MsgX;
float MsgY;

int HudWidth;
int HudHeight;
bool isTextFont;

// true if text lines should be centred
bool bCentreX;

float HoldTime;
float Time;

/*ClientGameShared*/ClientGameBase ClGame;


//==========================================================================
//
//  IsActive
//
//==========================================================================
final bool IsActive () {
  if (!ClGame || !ClGame.Game) return true; // just in case
  if (ClGame.Game.isPaused) return false; // paused
  // check scheduled tic
  if (!ClGame.GLevel) return true; // just in case
  if (ClGame.GLevel.TicTime < ticStart) return false; // not active yet
  return true; // active
}


//==========================================================================
//
//  Init
//
//==========================================================================
void Init (string Message, name AFont, int Type, int AId, int Colour,
  float AMsgX, float AMsgY, int AHudWidth, int AHudHeight, float AHoldTime,
  float Time1, float Time2)
{
  Time = 0;

  //print("HUDMSG(%d): font=[%s]; pos=(%f,%f); size=(%d,%d); msg=<%q>; HoldTime=%s; times=(%s,%s)", AId, AFont, AMsgX, AMsgY, AHudWidth, AHudHeight, Message, AHoldTime, Time1, Time2);
  ticStart = (ClGame && ClGame.GLevel ? ClGame.GLevel.TicTime+1 : 0); // schedule to next tic

  Id = AId;
  MsgFont = AFont;
  if (!MsgFont) { MsgFont = 'smallfont'; AFont = MsgFont; }
  MsgColour = Colour;
  HoldTime = AHoldTime;
  HoldTime = fclamp(HoldTime, 0, 100000); // 0 MEANS ALOT HERE!
  //if (HoldTime > 0) HoldTime += 0.5/35.0;

  if (GetCvarB('hud_scale_messages')) {
    string fontnamestr = string(AFont);
    isTextFont =
      (stricmp(fontnamestr, "confont") == 0) ||
      (stricmp(fontnamestr, "smallfont") == 0) ||
      (stricmp(fontnamestr, "smallfont2") == 0) ||
      (stricmp(fontnamestr, "bigfont") == 0);
  }
  // check for spaces
  /*
  if (isTextFont) {
    bool allSpaces = true;
    foreach (auto f; 0..Message.length) if (Message[f] > 32) { allSpaces = false; break; }
    if (!allSpaces) {
      print("HUDMSG: font=<%s>; pos=(%f,%f); size=(%d,%d); msg=<%q>", AFont, AMsgX, AMsgY, AHudWidth, AHudHeight, Message);
    }
  }
  */

  auto root = GetRootWidget();
  if (Width != root.Width || Height != root.Height) {
    //SetSize(GetVirtualWidth(), GetVirtualHeight());
    SetSize(root.Width, root.Height);
  }

  int wrapWidth = GetVirtualWidth()-32;

  // position of the message
  MsgX = AMsgX;
  MsgY = AMsgY;
  if (AHudWidth == 0 || AHudHeight == 0) {
    /*
    writeln("HUD0: ", AHudWidth, "x", AHudHeight, "; msgx=", AMsgX, "; msgy=", AMsgY);
    SetSize(GetVirtualWidth(), GetVirtualHeight());
    Width = GetVirtualWidth();
    Height = GetVirtualHeight();
    writeln("  size: ", Width, "x", Height);
    */
    if (fabs(MsgX) > 2.0) {
      bCentreX = true;
      MsgX = 0.5;
    } else {
      if (fabs(MsgX) > 1.0) bCentreX = true;
      MsgX = (MsgX > 1.0 ? MsgX-1.0 : MsgX < -1.0 ? MsgX+1.0 : MsgX);
    }
    if (fabs(MsgY-0.5) <= 0.1) {
      if (MsgY <= 0.5) MsgY -= 0.1; else MsgY += 0.1;
    }

    int wx = GetVirtualWidth()-int(GetVirtualWidth()*(fabs(MsgX)*2))-32;
    if (wx < 32) {
      wrapWidth = 640-32;
    } else {
      wrapWidth = max(320, min(wrapWidth, wx));
    }
  } else {
    //writeln("HUD1: ", AHudWidth, "x", AHudHeight);
    HudWidth = AHudWidth;
    HudHeight = AHudHeight;
    wrapWidth = abs(HudWidth);

    /*
    auto root = GetRootWidget();
    if (root) {
      if (Width != root.Width || Height != root.Height) {
        //SetSize(GetVirtualWidth(), GetVirtualHeight());
        SetSize(root.Width, root.Height);
      }
    }
    */

    /*
    SetFont(MsgFont);
    int tw = TextHeight(va("%q", Message));
    if (tw > TextHeight("AW")+4) {
      // this must be a picture
      isTextFont = false;
    }
    print("%n:<%q>", AFont, Message);
    */

    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    if (FracPart&4) bCentreX = true;
    if (MsgX > 0.0) {
      MsgX = float(IntPart)+float(FracPart&3)/10.0;
    } else {
      MsgX = float(IntPart)-float(FracPart&3)/10.0;
    }

    if (!isTextFont) {
      float sx = float(root.Width)/float(abs(HudWidth));
      float sy = float(root.Height)/float(abs(HudHeight));
      ScaleX = sx;
      ScaleY = sy;
      //print("  scale:(%f,%f); scaled size:(%s, %s); vsize=(%s,%s); rsize=(%s,%s)", sx, sy, round(root.Width/sx), round(root.Height/sy), GetVirtualWidth(), GetVirtualHeight(), root.Width, root.Height);
      SetSize(round(root.Width/sx), round(root.Height/sy));
      //root.dumpClipRect();
      //print("============"); for (Widget ww = self; ww; ww = ww.Parent) { print("ww=%C", ww); ww.dumpClipRect(); }
    } else {
      float sx = float(root.Width)/float(abs(HudWidth));
      int wx = GetVirtualWidth()-round(MsgX*sx)*2-32;
      //print("*** wx=%d", wx);
      if (wx < 32) {
        wrapWidth = GetVirtualWidth()-32;
      } else {
        wrapWidth = max(320, min(wrapWidth, wx));
      }
    }
  }

  // calculate width and height of the text
  if (Message != oldtext || AFont != oldfont) {
    MsgLines.length = 0;
    SetFont(MsgFont);
    MsgHeight = SplitText(Message, MsgLines, /*Width*/wrapWidth);
    //print("========= <%q> (%s:%s) =========", Message, MsgLines.length, wrapWidth);
    MsgWidth = 0;
    foreach (auto i; 0..MsgLines.length) {
      //print("  #%d: <%q>", i, MsgLines[i].Text);
      if (MsgLines[i].Width > MsgWidth) MsgWidth = MsgLines[i].Width;
    }
  }
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  int x, y;

  SetFont(MsgFont);

  auto root = GetRootWidget();
  /*
  if (Width != root.Width || Height != root.Height) {
    //SetSize(GetVirtualWidth(), GetVirtualHeight());
    SetSize(root.Width, root.Height);
  }
  */
  //print("rhgt=%d; hgt=%d; vhgt=%d", root.Height, Height, GetVirtualHeight());

  if (HudWidth == 0) {
    //writeln("HUD0: ", HudWidth, "x", HudHeight, "; msgx=", MsgX, "; msgy=", MsgY);
    //writeln("  size: ", Width, "x", Height);

    if (MsgX > 0.0) {
      x = int(float(Width-MsgWidth)*MsgX);
    } else {
      x = int(float(Width)*(-MsgX));
    }
    if (MsgY > 0.0) {
      y = int(float(Height-MsgHeight)*MsgY);
    } else {
      y = int(float(Height)*(-MsgY));
    }
  } else {
    int msgwdt = MsgWidth;
    int msghgt = MsgHeight;
    x = int(MsgX);
    y = int(MsgY);

    //float sx = float(GetVirtualWidth())/float(abs(HudWidth));
    //float sy = float(GetVirtualHeight())/float(abs(HudHeight));
    if (isTextFont) {
      //FIXME: make big scales work as expected
      float sx = float(root.Width)/float(abs(HudWidth));
      float sy = float(root.Height)/float(abs(HudHeight));
      /*
      print("HUDMSG: msg=<%q>; pos=(%d,%d); fixedpos=(%d,%d); scale=(%f,%f); size=(%d,%d); hudsize=(%d,%d)", MsgLines[0].Text, x, y, round(x*sx), round(y*sy), sx, sy, Width, Height, HudWidth, HudHeight);
      dumpClipRect("self");
      root.dumpClipRect("root");
      */
      x = round(x*sx);
      y = round(y*sy);
      // scale this, so center will work properly
      //msgwdt = round(msgwdt*sx);
      //msghgt = round(msghgt*sx);
      //ScaleX = 1;
      //ScaleY = 1;
    }

    //print("msg=<%q>", MsgLines[0].Text);
    int IntPart = int(MsgX);
    int FracPart = int(fabs(MsgX-float(IntPart))*10.0+0.5);
    //print("  x=%d; frac=%d", x, FracPart);
    // fractional part specifies alignment:
    //   0 - centre
    //   1 - left
    //   2 - right
    switch (FracPart&3) {
      case 0: x -= MsgWidth/2; break;
      case 2: x -= MsgWidth; break;
    }

    IntPart = int(MsgY);
    FracPart = int(fabs(MsgY-float(IntPart))*10.0+0.5);
    //print("  y=%d; frac=%d", y, FracPart);
    // fractional part specifies alignment:
    //   0 - centre
    //   1 - top
    //   2 - bottom
    switch (FracPart&3) {
      case 0: y -= MsgHeight/2; break;
      case 2: y -= MsgHeight; break;
    }

  }

  foreach (auto i; 0..MsgLines.length) {
    if (bCentreX) {
      DrawLine(i, x+(MsgWidth-MsgLines[i].Width)/2, y, MsgLines[i].Text);
    } else {
      DrawLine(i, x, y, MsgLines[i].Text);
    }
    y += MsgHeight/MsgLines.length;
  }
}


//==========================================================================
//
//  DrawLine
//
//==========================================================================
void DrawLine (int LineIdx, int x, int y, string Text) {
  float alpha = (isTextFont ? MsgAlpha : (MsgAlpha >= 1 ? 0.99 : MsgAlpha));
  DrawText(x, y, Text, MsgColour, CR_YELLOW, alpha);
}


//==========================================================================
//
//  Tick
//
//==========================================================================
override void Tick (float DeltaTime) {
  if (!IsActive) return; // do not tick when game is paused
  if (HoldTime && Time > HoldTime) {
    //print("TIME=%s; HoldTime=%s; tfrm=%s; htfrm=%s; <%q>", Time, HoldTime, Time/35.0, HoldTime/35.0, (MsgLines.length ? MsgLines[0].Text : "<>"));
    MarkDead(); //Destroy();
    return;
  }
  // moved here, so messages won't blink
  Time += DeltaTime;
}


defaultproperties {
  Width = 640;
  Height = 480;
  bTickEnabled = true;
  MsgAlpha = 1.0;
}
