//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**  Copyright (C) 1999-2006 Jānis Legzdiņš
//**  Copyright (C) 2018-2020 Ketmar Dark
//**
//**  This program is free software: you can redistribute it and/or modify
//**  it under the terms of the GNU General Public License as published by
//**  the Free Software Foundation, version 3 of the License ONLY.
//**
//**  This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**  You should have received a copy of the GNU General Public License
//**  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//**
//**************************************************************************
class MenuSaveSlot : MenuChoiceSlot;

const int SLOTTEXTLEN = 24;

int Status;
bool bEnteringText;
int SlotNum;
string Text;
string EnterText;
bool waitingDeletion; // special rendering


//==========================================================================
//
//  OnCreate
//
//==========================================================================
override void OnCreate () {
  ::OnCreate();
  InitSlot();
}


//==========================================================================
//
//  OnDraw
//
//==========================================================================
override void OnDraw () {
  DrawStrikeLine = waitingDeletion;
  if (bEnteringText && IsFocused) {
    DrawSlot(0, EnterText, true);
  } else {
    DrawSlot(0, Text, false, (Status ? CR_UNTRANSLATED : CR_DARKBROWN));
  }
  DrawStrikeLine = false;
}


//==========================================================================
//
//  OnFocusReceived
//
//==========================================================================
override void OnFocusReceived () {
  waitingDeletion = false;
  ::OnFocusReceived();
}


//==========================================================================
//
//  OnFocusLost
//
//==========================================================================
override void OnFocusLost () {
  waitingDeletion = false;
  ::OnFocusLost();
}


//==========================================================================
//
//  ActivateSlot
//
//==========================================================================
void ActivateSlot () {
}


//==========================================================================
//
//  OnEvent
//
//==========================================================================
override bool OnEvent (ref event_t evt) {
  if (evt.bubbling && evt.type == ev_keydown) {
    if (bEnteringText) {
      // save game string input
      switch (evt.keycode) {
        case K_ESCAPE:
        //case K_MOUSE2:
          waitingDeletion = false;
          bEnteringText = false;
          break;
        case K_ENTER:
        case K_PADENTER:
        //case K_MOUSE1:
        case K_JOY1:
          waitingDeletion = false;
          bEnteringText = false;
          if (evt.keycode == K_JOY1 && !EnterText) EnterText = va("saved game %d", SlotNum);
          if (EnterText) {
            Text = EnterText;
            CmdBuf_AddText("Save %d \"%q\"\n", SlotNum, Text);
            GetClGame().ForceMenuOff();
          }
          break;
        case K_BACKSPACE:
          waitingDeletion = false;
          if (EnterText) EnterText = EnterText[0..$-1];
          break;
        default:
          if (EnterText.length < SLOTTEXTLEN-1) {
            string tk = TranslateKey(evt.keycode);
            if (tk && tk[0] >= 32 && tk[0] < 128) {
              EnterText ~= tk;
            }
          }
          break;
      }
      return true;
    }

    switch (ConvertBoundKey(evt.keycode)) {
      case K_DELETE:
      case K_PADDOT:
        if (Status) {
          if (!waitingDeletion) {
            waitingDeletion = true;
          } else {
            waitingDeletion = false;
            Status = 0;
            Text = "*deleted slot*";
            //print("DEL! slot=%d; status=%d", SlotNum, Status);
            CmdBuf_AddText("DeleteSavedGame %d\n", SlotNum);
            auto pm = MenuScreenLoadSaveGame(Parent);
            if (pm) pm.SignalSlotDeletion();
          }
        }
        return true;
      case K_INSERT:
      case K_PAD0:
        waitingDeletion = false;
        return true;
      case K_ENTER:
      case K_PADENTER:
      //case K_MOUSE1:
      case K_JOY1:
        waitingDeletion = false;
        ActivateSlot();
        return true;
    }
  }

  if (evt.bubbling && evt.type == ev_keyup && bEnteringText) {
    return true;
  }

  return ::OnEvent(evt);
}


//==========================================================================
//
//  OnMouseClick
//
//==========================================================================
override void OnMouseClick (int X, int Y, int Button, Widget Dest) {
  if (Dest != self) return;
  SetFocus();
  waitingDeletion = false;
  if (Button == K_MOUSE1) {
    /*
    if (bEnteringText) {
      bEnteringText = false;
      if (EnterText) {
        Text = EnterText;
        CmdBuf_AddText("Save %d \"%q\"\n", SlotNum, Text);
        GetClGame().ForceMenuOff();
      }
    }
    */
    ActivateSlot();
  } else if (Button == K_MOUSE2) {
    GetClGame().PopMenu();
  }
}


defaultproperties {
}
